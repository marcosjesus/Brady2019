=======================================================================
Bug fixes and enhancements applied to Orpheus version 4.00 for 4.01
=======================================================================
Ch#     file(s)       type description
=======================================================================

1.      ovcdbpf       fix  Selection doesn't change when the field's
                           data is updated.

2.      ovcoutln      fix  "OvcOutline1 has no parent" destruction
                           error

3.      ovcoutln      fix  OvcOutline Stack overflow bug.

4.      ovcsc         fix  OvcSpinner wouldn't re-initialize the
                           autorepeat sequence if AutoRepeat was
                           toggled off in the OnClick event and toggled
                           back on outside of the event, such as in a
                           timer.

5.      ovcclock      fix  The OvcClock's digital display does not
                           display itself properly at construction and
                           it does not respect designtime settings at
                           runtime.

6.      ovcreg        fix  The property editor for TO32Collection
                           descendants registers itself for all
                           TCollection descendants.

7.      ovcoutln      fix  Destruction bug in the OvcOutline causes
                           Delphi to throw a mysterious access
                           violation when the IDE is closed.

8.      ovcpf         fix  Destruction order problem with the OvcTable
                           causes an exception in efTransfer in some
                           circumstances.

9.      O32VPool      fix  Added support for trial run to the unit.

10.     O32Vldtr      fix  Added support for trial run to the unit.

11.     OvcPF         fix  Backed out change #8 as it was un-necesssary

12.     O32ImgFm      fix  Added support for trial run to the unit.

13.     OvcLobEd      fix  Removed the disabled folder editor from the
                           O32LookoutBar.

14.     O32IGrid      enh  Published the InspectorItem's ItemsList
                           property

15.     O32IGrid      fix  A bug in the O32GridCombo prevented a List
                           item from being updated programatically.

=======================================================================
Bug fixes and enhancements applied to Orpheus version 4.01 for 4.02
=======================================================================
Ch#     file(s)       type description
=======================================================================

16.     ovcvlb        enh  Now displays proportional horizontal scroll
                           bar

17.     ovcoutln      fix  Painting of lines wrong for last top-level
                           item

18.     ovcoutln      enh  Hint logic simplified and standardized

19.     ovcoutln      enh  Outline now support a horizontal scroll bar

20.     OvcLkout      fix  Rapid folder change fires the OnChange event
                           before the previous folder change is
                           finished.

21.     O32SBar       fix  When status Bar attempts to resize its
                           contained controls, non-visual components
                           caused an "Invalid Typecast error".

22.     O32IGrid      fix  OnGetEditMask and OnGetEditText wouldn't
                           transfer the user specified strings to the
                           component.

23.     OvcCmbx       fix  Delphi 6's overriding of SetItemHeight
                           causes the combo box to draw itself too
                           short.

24.     OvcCmbx       fix  The new AutoComplete property inherited from
                           TCustomComboBox in Delphi 6 causes undesired
                           results in many of the Orpheus combo boxes.

25.     OvcSplDg      fix  Access violation if the spash dialog's image
                           has not been set.

26.     OvcBase       fix  OvcController creation problem.

27.     O32flxed      fix  FlexEdit causes INVALID WINDOW HANDLE error
                           when compiled with runtime packages.

28.     OvcRvIdx      fix  Indexer bug could cause data duplication in
                           report views.

29.     OvcRvPDg      fix  Report view print dlg fails to check for no
                           printer installed.

30.     OvcBtnHd      fix  Button header did not enforce setting Allowed
                           to False in OnRearrage.

31.     OvcRptVw      fix  Report view reports that dragging grouped
                           columns is not allowed but moves column anyway

32.     OvcRvPDg      fix  Report view print dlg fails to listen for
                           destruction of associated report view.

33.     OvcDRpVw      fix  Failed to generate OnFormatFloat event for
                           totals.

34.     OvcBtnHd      fix  Buttons did not travel when depressed

35.     O32FlxEd      fix  FlexEdit won't compile when compiling with
                           runtime packages.

36.     *.pas         enh  Re-enabled stack frames throughout the
                           library

37.     OvcBase       fix  Fix number 26 caused problems with the
                           ReportView's View Designer.

38.     OvcBase       fix  Many frame related problems.

39.     OvcEdit       fix  Memory Leak, Editors don't free the margins
                           at destruction.

40.     OvcTable      enh  otoBrowseRow, disabled otoRowSize which
                           doesn't seem necessary

41.     OvcRptVw      enh  New property, SortDirection on view fields

42.     O32IGrid      fix  ReadOnly property was left out of the
                           TO32InspectorItem

43.     OvcState      fix  If the storage hasn't been created yet, the
                           FormState assigns some default values to the
                           form, without regard to the state loaded
                           from the dfm.

44.     OvcDbTbl      fix  TOvcTCBaseEntryField descendants were not
                           being properly formatted in the table.

45.     Many Files    fix  Hdc changed to TOvcHdc for BCB Compatibility

46.     Many Files    fix  HWnd changed to TOvcHWnd for BCB
                           Compatibility

47.     OvcClrCb      fix  Colors weren't being displayed properly in
                           the dbColorComboBox.

48.     O32DbFe       fix  The dbFlexEdit wouldn't post changes to the
                           dataset if WantReturns or WordWrap were true.

49.     OvcOutln      enh  CacheSize property added.

50.     OvcEdit       fix  Bottom row drops below the bottom of the
                           editor.

51.     OvcEdit       fix  Flicker in the edit components.

52.     OvcRvIdx      fix  Changed view not saved properly.

53.     OvcRvIdx      enh  Indexer optimized when building grouped
                           views from scratch.

54.     OvcRptVw      fix  Custom views could not be deleted

55.     OvcViewEd     enh  Field panels changed to scroll boxes

56.     OvcTCHdr      fix  Table Header Cell component doesn't respect
                           color and font settings.

57.     ovcstore      fix  Couldn't update any tags after an emtpy value
                           had been saved.

58.     OvcMeter      enh  OwnerDraw event added to the OvcMeter.

59.     O32Igrid      fix  Pressing enter while editing a string field,
                           marked the data as unchanged.

60.     O32IGrid      fix  Using the ItemCollection property editor
                           caused an error in Delphi.

61.     ovcsc         fix  OvcSpinner deadlocks at initialization.

62.     ovccmbx       fix  Could not reload internal MRUList

63.     OvcDbPf       enh  Added support for the new DbExpress
                           TimeStamp field type to the
                           OvcDbPictureField.

64.     O32FlxEd      fix  Changing alignment caused the text to
                           disappear.

65.     O32SBar       enh  Modified FixControls for optimization.

=======================================================================
Bug fixes and enhancements applied to Orpheus version 4.02 for 4.03
=======================================================================
Ch#     file(s)       type description
=======================================================================

66.     OvcEditP      fix  The OvcTextFileEditor displays the control
                           character for a carriage return (#13).

67.     OvcURL        enh  Added an UnderlineURL property.

68.     O32FlxEd      fix  AutoSelect did not work.

69.     O32FlxEd      fix  FlexEdit is not respecting the
                           efColors.disabled color settings.

70.     OvcTable      fix  Longstanding Scroll Range Bug.

71.     O32IGrid      fix  Logical item type creates more than one pair
                           of True/False selections.

72.     OvcRptVw      fix  Printing does not respect the value of the
                           Visible property on view fields

73.     O32FlxBn      fix  OnItemChange event wasn't being fired.

74.     O32IGrid      fix  OnCellPaint surfacing the wrong event.

75.     OvcRegIS      fix  Delphi 6 requires DsgIntf be replaced by
        OvcRegAP           DesignIntf.
        OvcRegFF
        OvcRegTT
        OvcRxPe

76.     O32TCFlx      fix  TO32TCValidatorOptions ValidatorClass
                           property needs to be demoted from published
                           to public. (This only affects BCB users).

77.     O32Lkout      enh  Added a new SetActiveItem procedure along
                           with the ability to clamp the newly selected
                           item in view.

78.     OvcTimer      fix  Moved the Timer Handle removal back up above
                           the event handler calls, again.

79.     OvcBase       fix  Attached Label reference isn't being nil'ed
                           in the O32CustomControl's destructor.

80.     OvcSpldg      fix  OvcSplashDialog no longer supports JPG iamge
                           files.

81.     OvcBase       fix  Use of an attached label marks the form as
                           dirty, even when nothing has been changed.

82.     OvcFlxEd      enh  Added SoftValidation to the FlexEdit.
        O32VLOp1

83.     O32TCFlx      fix  The OnUserValidation event was not surfaced.

84.     OvcMRU        enh  The OvcMRU menu items were modified to
                           default the hint property to the MRU Item's
                           text.

85.     OvcTCHdr      fix  Bug prevented the column header caFontColor
                           from respecting the font color settings.

86.     OvcPf         fix  Substitution characters don't get replaced
                           in a date or time picture field.

=======================================================================
Bug fixes and enhancements applied to Orpheus version 4.03 for 4.04
=======================================================================
Ch#     file(s)       type description
=======================================================================

87.     OvcCal        fix  There is no way to change the calendar's
                           background color

88.     OvcTable      fix  OnEnteringColumn and OnEnteringRow were
                           being fired at the wrong times.

89.     Ovcef         fix  If the value of RangeHi or RangeLo being
                           changed caused the value of the field to be
                           out of range, the error wasn't being thrown,
                           and the field's display wasn't being
                           updated.

90.     OvcTimer      fix  Timer failed to call user defined trigger
                           events for anytihng but recurring timers.

91.     OvcCmbx       fix  ComboBox Height would not change with
                           font height changes.

92.     OvcDbIdx      fix  Delphi 6 throws an access violation when the
                           TOvcDbIndexSelect is destroyed.

93.     ovcbcalc      fix  memory leak. FButtonGlyph wasn't being
                           freed.

94.     OvcBordr      fix  memory leak. FLabelInfo wasn't being freed.

95.     O32TCFlx      fix  memory leak. FValidation wasn't being freed.

96.     OvcFmCbx      fix  memory leaks. The objects assigned to the
                           items list were not being freed.

97.     OvcCklb       enh  Added OwnerDrawCheck event.

98.     Ovccklb       enh  Added ReadOnly property.

99.     O32IGrid      enh  Hint and Tag properties have been published.

100.    O32FlxEd      fix  FlexEdit wouldn't adjust its height when the
                           font was changed.

101.    OvcDvCbx      enh  Added a FirstScannedDrive property to
                           prevent the drive combo box from polling
                           floppies when it populates itself.

102.    O32TCFlx      fix  ButtonGlyph caused access violation at
                           designtime.

103.    OvcCaret      fix  "No Parent Window" Error thrown in the Edit
                           field's destructors.

104.    Ovc.inc       fix  CBuilder isn't being properly defined in
                           C++Builder 6. As a result, some Delphi only
                           code is being compiled instead of some
                           C++Builder specific code.

105.    OvcEf         fix  Leading spaces get trimmed off improperly if
                           the width of the control is too narrow to
                           allow the entire string to be displayed.

106.    OvcDbCal      fix  Published the Color property in the
                           OvcDbCalendar.

107.    OvcEf         fix  Fix number 105 wasn't good enough.

108.    OvcRptVw      fix  Report view does not allow deletion of custom
                           fields and views.

109.    OvcRptVw      enh  Report view now truncates group headers if
                           they would otherwise overwrite a total column.

110.    OvcRptVw      enh  Loading logic for custom views optimized

111.    OvcRptVw      fix  Changing visib. of view column causes recalc.

112.    OvcRptVw      enh  View no longer scrolls when columns are resized

113.    OvcRptVw      fix  Key search now works for filtered views

114.    OvcRptVw      fix  Group sorting on calculated fields fixed

115.    OvcRptVw      fix  Incorrect page calc. for grouping headers

116.    OvcRvIdx      fix  Sorting of sub-groups not always correct

117.    OvcDRpVw      enh  Various performance enhancements

118.    O32FlxEd      fix  FlexEdit component ignores the value of the
                           PasswordChar property.

119.    O32FlxBn      fix  The FlexButton's OnChange event was being
                           fired as the button was being created,
                           before the parent form's OnCreate event was
                           fired.

120.    O32IGrid      fix  The InspectorGrid flickers madly when the
                           columns are resized.

121.    O32IGrid      fix  Cell editors don't follow the cell when the
                           control is resized.

122.    OvcTable      fix  The OvcTable was firing the OnEnteringRow
                           and OnEnteringCol as each cell was being
                           painted.  This is incorrect as the column
                           and row are not actually being entered, just
                           painted.

123.    OvcEF         fix  Focus problems with the Ovc*Edit fields.

124.    OvcTable      fix  Scrollbar recursion problems in the OvcTable

125.    OvcDrCbx      fix  FullName returned invalid results in some
                           instances.

126.    OvcFmCbx      fix  fix number 96 introduces an "Index Out Of
                           Range" error.

127.    OvcDrCbx      fix  Fix Access violation which occurs when
                           path = ''.

128.    OvcEf         fix  Fix 89 needed to check of the parent was
                           visible and enabled before attempting to
                           call SetFocus.

=======================================================================
Bug fixes and enhancements applied to Orpheus version 4.03 for 4.04
=======================================================================
Ch#     file(s)       type description
=======================================================================

129.    O32ImgFm      fix  The ImageForm's DragControl property should
                           not be allowed to be set to Self.  This
                           causes the ImageForm component to intercept
                           all click events as if it were the header
                           bar in a normal window.

***********************************************************************
***********************************************************************
*                         Full Text of Change                         *
***********************************************************************
***********************************************************************

***********************************************************************
1.      ovcdbpf       fix  Selection doesn't change when the field's
                           data is updated.
***********************************************************************
Fix by modifying the very bottom of the pfdbSetFieldValue procedure as
follows...

procedure TOvcDbPictureField.pfdbSetFieldValue;
var
  S  : string[MaxEditLen];
  << snip >>
  TL : longint;
begin
  if efdbBusy then
    Exit;

  << snip >>

      efPositionCaret(False);
    end else if (esSelected in pfdbState) then
      SetSelection(SS, SE);

    {adjust highlight and caret position}
    if esReset in pfdbState then begin
      SetSelection(0, Length(Text));                                  {!!.01}
      efResetCaret;                                                   {!!.01}
      efPositionCaret(True);                                          {!!.01}
      Exclude(pfdbState, esReset);
    end;
  end;
end;

***********************************************************************
2.      ovcoutln      fix  "OvcOutline1 has no parent" destruction
                           error
***********************************************************************
Fix by adding a check for HandleAllocated to the Clear procedure. 

procedure TOvcCustomOutline.Clear;
var
  Node: TOvcOutlineNode;
  NotifyDestroy: Boolean;
begin
  BeginUpdate;
 << snip >>
    FNodeIndex.Clear;
    if HandleAllocated then                                    {!!.01}
      NumItems := 0;
  finally
  << snip >>
end;

***********************************************************************
3.      ovcoutln      fix  OvcOutline Stack overflow bug.
***********************************************************************
Fix by modifying the LocateNode procedure in the IndexFromNode function
as follows...

function TOvcCustomOutline.IndexFromNode(CurNode : TOvcOutlineNode) 
  : LongInt;
var
  c : LongInt;

  procedure LocateNode(Nodes : TOvcOutlineNodes);
  var
    Node: TOvcOutlineNode;
  begin
    PushChildIndex;
    Node := Nodes.FirstChild;                                   {!!.01}
    if Node <> nil then
      repeat
        inc(c);
        if Node = CurNode then begin
          Result := c;
          break;
        end;
        if Node.Expanded and Node.HasChildren then
          LocateNode(Node.GetChildren);
        Node := Nodes.NextChild;                                {!!.01}
      until Node = nil;
    PopChildIndex;
  end;
begin
  c := -1;
  Result := -1;
  LocateNode(Nodes);
end;

***********************************************************************
4.      ovcsc         fix  OvcSpinner wouldn't re-initialize the
                           autorepeat sequence if AutoRepeat was 
                           toggled off in the OnClick event and toggled
                           back on outside of the event, such as in a 
                           timer.
***********************************************************************
Fix as follows...

Add a new SetAutoRepeat prototype to the TOvcSpinner class declaration
and modify the AutoRepeat property to write to the new procedure rather 
than the field itself.

  TOvcSpinner = class(TOvcCustomControl)
  protected {private}
    {property variables}
  << snip >>

    {property methods}
    procedure SetAcceleration(const Value : Integer);
    procedure SetAutoRepeat(Value: Boolean);                          {!!.01}
    procedure SetShowArrows(const Value : Boolean);
    procedure SetStyle(Value : TOvcSpinnerStyle);

    {internal methods}
  << snip >>

  published
    {properties}
    property Acceleration : Integer
      read FAcceleration write SetAcceleration;
    property AutoRepeat : Boolean
      read FAutoRepeat write SetAutoRepeat;                           {!!.01}
    property Delta : Double
      read FDelta write FDelta;
  << snip >>
  end;

Define the SetAutoRepeat implementation as follows...

<< snip >>

procedure TOvcSpinner.SetAcceleration(const Value : Integer);
begin
  if Value <= 10 then
    FAcceleration := Value;
end;

{!!.01 - begin}
procedure TOvcSpinner.SetAutoRepeat(Value: Boolean);
begin
  FAutoRepeat := Value;
  if FAutoRepeat then
    scDoAutoRepeat;
end;
{!!.01 - end}

procedure TOvcSpinner.SetBounds(ALeft, ATop, AWidth, AHeight: Integer);
var
  L, T, H, W : Integer;
begin
<< snip >>

***********************************************************************
5.      ovcclock      fix  The OvcClock's digital display does not 
                           display itself properly at construction and
                           it does not respect designtime settings at  
                           runtime.
***********************************************************************
Fix by modifying the DigitalOptions class' constructor and 
OvcCustomClock's Loaded procedure as follows...

constructor TOvcDigitalOptions.Create;
begin
  << snip >>
  MilitaryTime   := True;                                             {!!.01}
end;
{=====}

<< snip >>

procedure TOvcCustomClock.Loaded;
var
  HA : Boolean;
begin
  inherited Loaded;

  ckHandOptionChange(self);                                           {!!.01}
  ckDigitalOptionChange(self);                                        {!!.01}

  HA := FActive;
  FActive := False;
  SetActive(HA);
end;
{=====}


***********************************************************************
6.      ovcreg        fix  The property editor for TO32Collection 
                           descendants registers itself for all 
                           TCollection descendants.
***********************************************************************
Fix by modifying ovcreg.pas as follows...

  << snip >>
  {register component editor for the sub-component list}
  RegisterPropertyEditor(TypeInfo(TOvcCollection),nil,'',TOvcCollectionEditor);
{!!.01}
  RegisterPropertyEditor(TypeInfo(TO32Collection),nil,'',TO32CollectionEditor);

  {register label component editor}
  << snip >>


***********************************************************************
7.      ovcoutln      fix  Destruction bug in the OvcOutline causes  
                           Delphi to throw a mysterious access 
                           violation when the IDE is closed.
***********************************************************************
This fix requires that you rebuild your Orpheus packages 
afterwards. Fix by checking that the controller exists before removing 
the hovertimer, as follows...

destructor TOvcCustomOutline.Destroy;
{Destroy report view component}
begin
  Clear;
  FOnActiveChange := nil;
  HintShownHere := True;
  if FHoverTimer <> -1 then begin
    if FController <> nil then                                        {!!.01}
      FController.TimerPool.Remove(FHoverTimer);
    FHoverTimer := -1;
  end;
  HintWindow.Free;
  FNodes.Free;
  LineCanvas.Free;
  NodeCache.Free;
  FAbsNodes.Free;
  FNodeIndex.Free;                                                             
  inherited Destroy;
end;



***********************************************************************
8.      ovcpf         fix  Destruction order problem with the OvcTable 
                           causes an exception in efTransfer in some
                           circumstances.
***********************************************************************
It's more of a workaround than a fix. In ovcpf.pas edit the efTransfer
function as follows...

function TOvcCustomPictureField.efTransfer(DataPtr : Pointer; TransferFlag : Word) : Word;
  {-transfer data to/from the entry fields}
var
  P      : PChar absolute DataPtr;
  SP     : ^ShortString absolute DataPtr;
  Code   : Integer;

<< snip a lot >>

begin  {transfer}
  if DataPtr = nil then begin
    Result := 0;
    Exit;
  end;

  try                                                                 {11.01}
    case FPictureDataType of
      pftString   : TransferString;
      << snip >>
      pfTTime     : TransferTime;
    end;
    Result := inherited efTransfer(DataPtr, TransferFlag);
  except                                                              {!!.01}
    Result := 0;                                                      {!!.01}
  end;                                                                {!!.01}
end;


***********************************************************************
9.      O32VPool      fix  Added support for trial run to the unit.
***********************************************************************
implementation

uses
  {$IFDEF TRIALRUN} OrTrial, {$ENDIF}                                 {!!.01}
  Windows, SysUtils, Controls, Dialogs;

{$IFDEF TRIALRUN}                                                     {!!.01}
{$I ORTRIALF.INC}                                                     {!!.01}
{$ENDIF}                                                              {!!.01}


***********************************************************************
10.     O32Vldtr      fix  Added support for trial run to the unit.
***********************************************************************
implementation

uses
  {$IFDEF TRIALRUN} OrTrial, {$ENDIF} OvcVer;

{$IFDEF TRIALRUN}                                                     {!!.01}
{$I ORTRIALF.INC}                                                     {!!.01}
{$ENDIF}                                                              {!!.01}


***********************************************************************
11.     OvcPF         fix  Backed out change #8 as it was un-necesssary
***********************************************************************
See change #8 above.


***********************************************************************
12.     O32ImgFm      fix  Added support for trial run to the unit.
***********************************************************************
implementation

uses
  {$IFDEF TRIALRUN} OrTrial, {$ENDIF}                                 {!!.01}
  OvcVer;

{$IFDEF TRIALRUN}                                                     {!!.01}
{$I ORTRIALF.INC}                                                     {!!.01}
{$ENDIF}                                                              {!!.01}


{===== TO32CustomImageForm ===========================================}

constructor TO32CustomImageForm.Create(AOwner: TComponent);
{$IFDEF TRIALRUN}                                                     {!!.01}
var                                                                   {!!.01}
  X : Integer;                                                        {!!.01}
begin                                                                 {!!.01}
  X := _CC_;                                                          {!!.01}
  if (X < ccRangeLow) or (X > ccRangeHigh) then Halt;                 {!!.01}
  X := _VC_;                                                          {!!.01}
  if (X < ccRangeLow) or (X > ccRangeHigh) then Halt;                 {!!.01}
{$ELSE}                                                               {!!.01}
  begin
{$ENDIF}                                                              {!!.01}


***********************************************************************
13.     OvcLobEd      fix  Removed the disabled folder editor from the
                           O32LookoutBar.
***********************************************************************
The Folder editor was disabled but was not removed from the
O32LookoutBar before 4.00 deployment.  Fix by modifyint ExecuteVerb,
GetVerb and GetVerbCount as follows...

{*** TO32LookoutBarEditor ***}
{8/15/01 - Disable the folder only component editor. - PB}

procedure TO32LookoutBarEditor.ExecuteVerb(Index : Integer);
begin
  if Index = 0 then                                                   {!!.01}
    EditLookOut(Designer, (Component as TO32LookOutBar));             {!!.01}
end;

function TO32LookoutBarEditor.GetVerb(Index : Integer) : string;
begin
  if Index = 0 then                                                   {!!.01}
    Result := 'Layout Tool...';                                       {!!.01}
end;

function TO32LookoutBarEditor.GetVerbCount : Integer;
begin
  Result := 1;                                                        {!!.01}
end;

***********************************************************************
14.     O32IGrid      enh  Published the InspectorItem's ItemsList
                           property
***********************************************************************
Move the TO32InspectorItem's ItemsList property from Public to
Published.

  { InspectorItem }
  TO32InspectorItem = class(TO32CollectionItem)
  protected {private}
    FType       : TO32IGridItemType;
  << snip >>
    function  GetElementsAsString: string;
    procedure SetElementsAsString(Value: string);

  public
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;
  << snip >>
    property Level: Integer read FLevel;
  published
    property Caption: string read FCaption write SetCaption;
    property ImageIndex: Integer read FImageIndex write FImageIndex;
    property ItemsList: TStringList read FItemsList write FItemsList; {!!.01}
{...}


***********************************************************************
15.     O32IGrid      fix A bug in the O32GridCombo prevented a List
                          item from being updated programatically.
***********************************************************************
Fix by modifying TO32GridCombo.UpdateContents as follows...

procedure TO32GridCombo.UpdateContents;
begin
  Items.Assign(Grid.Items[Grid.ActiveItem].ItemsList);                {!!.01}
  Self.ItemIndex :=                                                   {!!.01}
    self.Items.IndexOf(Grid.GetEditText(Grid.Col, Grid.ActiveRow));   {!!.01}
  MaxLength := Grid.GetEditLimit;
end;


***********************************************************************
16.     ovcvlb        enh  Now displays proportional horizontal scroll bar
***********************************************************************
The virtual list box now displays a scroll bar with thumb proportional to
the Columns property. Also, the type of the Columns property was changed
from byte to integer.


***********************************************************************
17.     ovcoutln      fix  Painting of lines wrong for last top-level item
***********************************************************************
Children of the last top-level item were displayed with graphics indicating
that more top-level items would follow.

Too many changes to list here.

***********************************************************************
18.     ovcoutln      enh  Hint logic simplified and standardized
***********************************************************************
The outline's logic for displaying pop-up hints with then full contents
of truncated fields was switches from using a custom timer event to using
the standard VCL hint display logic. The new code is smaller, simpler, and
uses less resources.

Too many changes to list here.

***********************************************************************
19.     ovcoutln      enh  Outline now support a horizontal scroll bar
***********************************************************************
A ScrollBars property has been added, and the outline can now display a
horizontal scroll bar, proportional to the length of the text of the
largest visible node.

Too many changes to list here.

***********************************************************************
20.     OvcLkout      fix  Rapid folder change fires the OnChange event
                           before the previous folder change is finished.
***********************************************************************
Change by adding a check for a FolderIndex of -1 before firing the OnChange
event, as follows...

procedure TOvcLookOutBar.MouseUp(Button : TMouseButton; Shift : TShiftState;
          X, Y : Integer);
var
  FolderIndex : Integer;
  ItemIndex   : Integer;
  Folder      : TOvcLookOutFolder;
  Item        : TOvcLookOutItem;
  FromItem    : TOvcLookOutItem;
  SourceName  : string;
begin
  if lobMouseDown then begin
  << snip >>
      end;

      if (ItemIndex = -1) and (FolderIndex <> -1) then begin          {!!.02}
        { Fire the OnFolderClick event. }
        DoFolderClick(Button, Shift, FolderIndex);
  << snip >>
  inherited MouseUp(Button, Shift, X, Y);
end;

***********************************************************************
21.     O32SBar       fix  When status Bar attempts to resize its
                           contained controls, non-visual components
                           caused an "Invalid Typecast error".
***********************************************************************
Fix by Adding checks to make sure that non-TControl and TGraphicControl
items are ignored.

procedure TO32SBContainer.FixControls;
var
  ParentForm : TCustomForm;
  << snip >>
    try
      {Ignore non-visual controls...}
      if (ParentForm.Components[I] is TControl)                       {!!.02}
      or (ParentForm.Components[I] is TGraphicControl) then begin     {!!.02}
        {Resize TControls as necessary}
        if (ParentForm.Components[I] is TControl) then
  << snip >>
          Control.Height := Self.Height;
          Control.Top := 0;
        end;
      end;                                                            {!!.02}
    except
      {swallow exceptions}
    end;
  end;
end;
{=====}

  << snip >>

procedure TO32SBContainer.InvalidateControls;
var
  ParentForm : TCustomForm;
  I          : Integer;
begin
  if FStatusBar = nil then exit;
  ParentForm := TCustomForm(FStatusBar.Owner);
  for I := 0 to ParentForm.ComponentCount - 1 do
    if(ParentForm.Components[I] is TControl)                          {!!.02}
    and ((ParentForm.Components[I] as TControl).Parent = self) then   {!!.02}
      (ParentForm.Components[I] as TControl).Invalidate;
end;
{=====}

***********************************************************************
22.     O32IGrid      fix  OnGetEditMask and OnGetEditText wouldn't
                           transfer the user specified strings to the
                           component.
***********************************************************************
Fix by changing the Mask and Text parameters to var params.

{...}
  {Events}
  To32IGridItemEvent =
    procedure(Sender: TObject; Item: Word) of object;
  <<snip>>
  TO32GetEditMaskEvent =
    procedure(Sender: TObject; Item: TO32InspectorItem;
              var Mask: string) of object;                            {!!.02}
  TO32GetEditTextEvent =
    procedure(Sender: TObject; Item: TO32InspectorItem;
              var Text: string) of object;                            {!!.02}
  {...}


***********************************************************************
23.     OvcCmbx       fix  Delphi 6's overriding of SetItemHeight
                           causes the combo box to draw itself too
                           short.
***********************************************************************
Fix by changing Override to reintroduce and remove the call to inherited

...

  TOvcBaseComboBox = class(TCustomComboBox)
  protected {private}
    {property variables}
    FAutoSearch   : Boolean;
  << snip >>
    procedure SetDroppedWidth(Value : Integer);
    procedure SetHotTrack(Value : Boolean);
    procedure SetItemHeight(Value : Integer);
      {$IFDEF VERSION6}reintroduce;{$ENDIF}                           {!!.02}
    function  GetListIndex: Integer;
  << snip >>

procedure TOvcBaseComboBox.SetItemHeight(Value : Integer);
begin
  if Value <> FItemHeight then begin
    FItemHeight := Value;
    {Caused improperly sized comboboxes in Delphi 6}                  {!!.02}
    (*{$IFDEF VERSION6}inherited{$ENDIF}*)                            {!!.02}
    SetItemHeight(Value{ + cbxSeparatorHeight});                      {!!.02}
    {force update of inherited ItemHeight}
    RecreateWnd;
  end;
end;

{...}


***********************************************************************
24.     OvcCmbx       fix  The new AutoComplete property inherited from
                           TCustomComboBox in Delphi 6 causes undesired
                           results in many of the Orpheus combo boxes.
***********************************************************************
Fix by publishing the AutoComplete property in TOvcBaseComboBox and
set it to false inthe constructor.

  TOvcBaseComboBox = class(TCustomComboBox)
  protected {private}
    {property variables}

  << big snip >>

      write SetHTBorder
      default True;

    property HotTrackColors : TOvcHTColors
      read FHTColors
      write SetHTColors;
    {$IFDEF VERSION6}                                                 {!!.02}
    property AutoComplete;                                            {!!.02}
    {$ENDIF}                                                          {!!.02}
  end;

  << snip >>

  constructor TOvcBaseComboBox.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);

  {$IFDEF VERSION6}                                                   {!!.02}
  AutoComplete := false;                                              {!!.02}
  {$ENDIF}                                                            {!!.02}

  FLabelInfo := TOvcLabelInfo.Create;

  {...}


***********************************************************************
25.     OvcSplDg      fix  Access violation if the spash dialog's image
                           has not been set.
***********************************************************************
To fix, add a check for the height to the beginning of the show
procedure as follows...

procedure TOvcSplashDialog.Show;
var
  DC           : hDC;
  BitsPerPixel : Word;
begin
{!!.02 - begin}
  // if there is no image assigned then fail and bail...
  if (FPictureHiRes.Bitmap.Height = 0) and (FPictureLoRes.Bitmap.Height = 0)
  then exit;
{!!.02 - end}

  if not Assigned(Splash) then
<< snip >>


***********************************************************************
26.     OvcBase       fix  OvcController creation problem.
***********************************************************************
To fix, modify TOvcCustomControlEx.SetController as follows...

procedure TOvcCustomControlEx.SetController(Value : TOvcController);
begin
  if not (TObject(Value) is TOvcController) then                       {!!.02}
    Value := nil;                                                      {!!.02}
  FController := Value;
  if Value <> nil then
    Value.FreeNotification(Self);
end;


***********************************************************************
27.     O32flxed      fix  FlexEdit causes INVALID WINDOW HANDLE error
                           when compiled with runtime packages.
***********************************************************************
Fix by modifying TO32CustomFlexEdit.CreateWindowHandle as follows...

procedure TO32CustomFlexEdit.CreateWindowHandle(const Params: TCreateParams);
begin
  if (FUpdating > 0) then exit;
{!!.02 - begin}
  if not HandleAllocated then
    inherited;
(*
  if not HandleAllocated then begin
    if (csDesigning in ComponentState) then
      inherited
    else begin
      with Params do
        WindowHandle := CreateWindowEx(ExStyle, WinClassName, '', Style,
          X, Y, Width, Height, WndParent, 0, HInstance, Param);
      SendMessage(WindowHandle, WM_SETTEXT, 0, Longint(Caption));
    end;
  end;
*)
{!!.02 - end}
end;
{=====}


***********************************************************************
28.     OvcRvIdx      fix  Indexer bug could cause data duplication in
                           report views.
***********************************************************************
The report view indexer could lose track of its position when processing
multiple updates. The symptom was data duplication in lists after an
update involving multiple items. To fix, make the following changes:

In ovcrvidx.pas, procedure TOvcRvIndex.ProcessUpdates:

procedure TOvcRvIndex.ProcessUpdates(Updates : TOvcList);
var
...
  Exists: Boolean;                                                     {!!.02}
begin
...
                if CurGroup.FAbsGroupColumn < 0 then
                  Rslt := 0 {group contains all items (supergroup - non-grouped view)}
                else
                  Rslt := FOwner.DoCompareFields(Node.Item, Item2, CurGroup.FAbsGroupColumn);
                if Rslt = 0 then begin {we matched another item in the group}
                  Updates.PushIndexPosition;                           {!!.02}
                  Exists := Updates.ItemExists(Item2);                 {!!.02}
                  Updates.PopIndexPosition;                            {!!.02}
                  if not Exists then begin                             {!!.02}
                    inc(MatchCount);
                    Belong := True; {If that item does not have a pending update, we're home free}
                    break;          {If it does, we have to keep searching}
                  end;
...
end;

in ovcdlm.pas, interface section:

  TOvcList = class
  ...
    property Count: Integer read FCount;
    procedure PushIndexPosition;                                       {!!.02}
    procedure PopIndexPosition;                                        {!!.02}
  end;

in ovcdlm.pas, implementation section:

{!!.02 new}
procedure TOvcList.PopIndexPosition;
begin
  Index.PopPosition;
end;

{!!.02 new}
procedure TOvcList.PushIndexPosition;
begin
  Index.PushPosition;
end;


***********************************************************************
29.     OvcRvPDg      fix  Report view print dlg fails to check for no
                           printer installed.
***********************************************************************

To fix, make the following changes to ovcrvpdg.pas:

procedure TOvcfrmRptVwPrintDlg.btnOkClick(Sender: TObject);
begin
  if Printer.Printers.Count = 0 then                                    {!!.02}
    raise Exception.Create('No printer installed');                     {!!.02}
  SetProperties;
...

procedure TOvcfrmRptVwPrintDlg.btnPreviewClick(Sender: TObject);
begin
  if Printer.Printers.Count = 0 then                                    {!!.02}
    raise Exception.Create('No printer installed');                     {!!.02}
  SetProperties;
...


***********************************************************************
30.     OvcBtnHd      fix  Button header did not enforce setting Allowed
                           to False in OnRearrage.
***********************************************************************

To fix, make the following changes to ovcbtnhd.pas:

procedure TOvcButtonHeader.MouseMove(Shift : TShiftState; X, Y : Integer);
...
begin
...
      if (Z <> -1) and (DragSection.Index <> Z) then begin
        if DoRearranging(DragSection.Index, Z) then begin
          if MoveFrom = -1 then
            MoveFrom := DragSection.Index;
          MoveTo := Z;
          DragSection.Index := Z;
        end else                                                       {!!.02}
          MoveTo := -1;                                                {!!.02}
      end;
...

procedure TOvcButtonHeader.MouseUp(Button : TMouseButton; Shift : TShiftState; X, Y : Integer);
...
begin
...
      FDragSection := nil;
      Invalidate;
      if (MoveFrom <> -1) and (MoveTo <> -1) then                      {!!.02}
        DoRearranged(MoveFrom, MoveTo);
      exit;
    end;
...

***********************************************************************
31.     OvcRptVw      fix  Report view reports that dragging grouped
                           columns is not allowed but moves column anyway
***********************************************************************

To fix, make the following change to ovcrptvw.pas:

function TOvcRVHeader.DoRearranging(OldIndex, NewIndex: Integer): Boolean;
begin
  if TOvcCustomReportView(Owner).CurrentView.ViewField[OldIndex].GroupBy      {!!.02}
  or TOvcCustomReportView(Owner).CurrentView.ViewField[NewIndex].GroupBy then {!!.02}
    Result := False
  else
    Result := inherited DoRearranging(OldIndex, NewIndex);
end;

***********************************************************************
32.     OvcRvPDg      fix  Report view print dlg fails to listen for
                           destruction of associated report view.
***********************************************************************

May cause crash at design-time if report view is deleted before the print
dialog. To fix, make the following changes to ovcrvpdg.pas:

In implementation:

  TOvcRvPrintDialog = class(TOvcBaseDialog)
  ...
  protected {private}
  ...
    procedure Notification(AComponent: TComponent; Operation: TOperation); override; {!!.02}
  public
  ...

In interface:

{!!.02 new}
procedure TOvcRvPrintDialog.Notification(AComponent: TComponent; Operation: TOperation);
begin
  if (Operation = opRemove) then
    if (AComponent = ReportView) then
      ReportView := nil;
  inherited Notification(AComponent, Operation);
end;


***********************************************************************
33.     OvcDRpVw      fix  Failed to generate OnFormatFloat event for
                           totals.
***********************************************************************
The data report view generated OnFormatFloat events for fields that have
their CustomFormat property set to True but failed to do so for total
fields. To fix, make the following changes to ovcdrpvw.pas:

function TOvcDataReportView.DoGetGroupString(ViewField : TOvcRvViewField; GroupRef : TOvcRvIndexGroup) : string;
var
  FieldIndex: Integer;
begin
  FieldIndex := ViewField.Field.Index;
  if TOvcDataRvField(Field[FieldIndex]).CustomFormat                   {!!.02}
  and assigned(FOnFormatFloat) then begin                              {!!.02}
    Result := '';                                                      {!!.02}
    FOnFormatFloat(Self, FieldIndex, Total(GroupRef, FieldIndex), Result); {!!.02}
  end else                                                             {!!.02}
    Result := SysUtils.FormatFloat(TOvcDataRvField(Field[FieldIndex]).Format, Total(GroupRef,FieldIndex));
end;


***********************************************************************
34.     OvcBtnHd      fix  Buttons did not travel when depressed
***********************************************************************
Bugs in the new support for drag-rearrange caused the buttons on the header to
not travel when pressed. Changes too numerous to list here.


***********************************************************************
35.     O32FlxEd      fix  FlexEdit won't compile when compiling with
                           runtime packages.
***********************************************************************
When packages are used, the window class is being registered in the package
(by TWinControl.CreateWnd). In TO32CustomFlexEdit.CreateWindowHandle, then,
you need to specify the instance to the package that registered the class
(VCL) instead of the current module (O4xx). The easiest way to do that is to
modify the CreateWindowHandle to use the instance from the class info being
passed in: (See changes marked with {!!.02})

procedure TO32CustomFlexEdit.CreateWindowHandle(const Params: TCreateParams);
begin
  if (FUpdating > 0) then exit;

  if not HandleAllocated then begin
    if (csDesigning in ComponentState) then
      inherited
    else begin
      with Params do
        WindowHandle := CreateWindowEx(ExStyle, WinClassName, '', Style,
          X, Y, Width, Height, WndParent, 0, WindowClass.HInstance,   {!!.02}
          Param);                                                     {!!.02}
      SendMessage(WindowHandle, WM_SETTEXT, 0, Longint(Caption));
    end;
  end;
end;
{=====}

***********************************************************************
36.     *.pas         enh  Re-enabled stack frames throughout the
                           library
***********************************************************************
IN order to re-enable stack frames, every instance of...
  {W-} {Windows Stack Frame}
was replaced with...
  {.W-} {Windows Stack Frame}                                        {!!.02}


***********************************************************************
37.     OvcBase       fix  Fix number 26 caused problems with the
                           ReportView's View Designer.
***********************************************************************
Note: You must rebuild your runtime and designtime packages after
making this change.  For more information on rebuilding your packages,
see the "Recompiling Orpheus Packages" topic in the ReadMe.hlp file.

To fix, Back out the changes in fix 26 (GetController) as follows...

function TOvcCustomControlEx.GetController: TOvcController;
begin
  if FController = nil then
    Result := DefaultController
  else
  Result := FController;
end;

And then modify SetController as follows...

procedure TOvcCustomControlEx.SetController(Value : TOvcController);
begin
  if not (TObject(Value) is TOvcController) then                       {!!.02}
    Value := nil;                                                      {!!.02}
  FController := Value;
  if Value <> nil then
    Value.FreeNotification(Self);
end;

***********************************************************************
38.     OvcBase       fix  Many frame related problems.
***********************************************************************
There are many problems with frames mostly regarding the attached label
as well as the improper functioning of the OvcTable cells when the frame
is placed on a form.

The fix is simple.  In OvcBase there is a function called
GetImmediateParentForm.  A typo in this function prevented descendant
components from correctly identifying a TCustomFrame as the parent.

Fix by modifying GetImmediateParentForm as follows.

Note:  As this modifies designtime behaviour, you will need to rebuild
your orpheus packages.  For more information on rebuilding your packages,
see the "Recompiling Orpheus Packages" topic in the ReadMe.hlp file.

function GetImmediateParentForm(Control : TControl) : TWinControl;
  {return first form found while searching Parent}
var
  ParentCtrl : TControl;
begin
  ParentCtrl := Control.Parent;
{$IFDEF VERSION5}
  while Assigned(ParentCtrl) and
    not ((ParentCtrl is TCustomForm) or
         (ParentCtrl is TCustomFrame)) do                             {!!.02}
{$ELSE}
  while Assigned(ParentCtrl) and (not (ParentCtrl is TCustomForm)) do
{$ENDIF}
    ParentCtrl := ParentCtrl.Parent;
  Result := TWinControl(ParentCtrl);
end;


***********************************************************************
39.     OvcEdit       fix  Memory Leak, Editors don't free the margins
                           at destruction.
***********************************************************************
Modify the TOvcCustomEditor's destructor as follows...

destructor TOvcCustomEditor.Destroy;
begin

  << snip >>

  {dispose the borders object}
  FBorders.Free;
  FBorders := nil;

  {dispose of the margins object}                                     {!!.02}
  FMargins.Free;                                                      {!!.02}
  FMargins := nil;                                                    {!!.02}

  inherited Destroy;
end;


***********************************************************************
40.     O32IGrid      fix  The InspectorGrid's OnChange event was being
                           fired before the item's contents had been
                           updated.
***********************************************************************
The fix is a little extensive but we wanted it to be right.

To fix, add the following UpdateCellContents procedure, and modify the
FocusCell and DoExit procedures as follows...

Declare UPdateCellContents in the protected section of the
TO32InspectorGrid's class declaration...

  TO32CustomInspectorGrid = class(TO32CustomControl)
  protected {private}
    FItemTextColor        : TColor;
  << snip >>
    procedure ClampInView(const Coord: TGridCoord);
    procedure DrawMove;
    procedure FocusCell(ACol, ARow: Longint; MoveAnchor: Boolean);
    procedure UpdateCellContents;                                     {!!.02}
    procedure GridRectToScreenRect(GridRect: TGridRect;
                var ScreenRect: TRect; IncludeLine: Boolean);
  << snip >>

In the Implementation section, add the following UpdateCellContents
implementation...

{!!.02 - new}
procedure TO32CustomInspectorGrid.UpdateCellContents;
var
  OldStr: string;
  OldColor: TColor;
  Changed: Boolean;
begin
  Changed := false;
  if (FItems.VisibleItems.Count = 0) then exit;
  { Update the grid with the editor's contents }
  if FInPlaceEdit <> nil then begin
    case TO32InspectorItem(FItems.VisibleItems[ActiveRow]).ItemType of
      itParent, itSet, itList, itString, itInteger, itFloat, itCurrency, itDate,
      itLogical:
      begin
        { Temporarily save the old value }
        OldStr := TO32InspectorItem(FItems.VisibleItems[ActiveRow]).AsString;
        { if the contents have been changed, then update the item }
        if OldStr <> GetEditorText then begin
          TO32InspectorItem(FItems.VisibleItems[ActiveRow]).AsString := GetEditorText;
          Changed := true;
        end;
      end;
      itColor:
      begin
        { Temporarily save the old color }
        OldColor := TO32InspectorItem(FItems.VisibleItems[ActiveRow]).AsColor;
        { if the color has changed then update the item }
        if (OldColor <> (FInplaceEdit as TO32GridColorCombo).SelectedColor)
        then begin
          TO32InspectorItem(FItems.VisibleItems[ActiveRow]).AsColor
            := (FInplaceEdit as TO32GridColorCombo).SelectedColor;
          Changed := true;
        end;
      end;
      itFont:
      begin
        OldStr := TO32InspectorItem(FItems.VisibleItems[ActiveRow]).AsFont.Name;
        if (OldStr <> (FInplaceEdit as TO32GridFontCombo).FontName) then begin
          TO32InspectorItem(FItems.VisibleItems[ActiveRow]).AsFont.Name
            := (FInplaceEdit as TO32GridFontCombo).FontName;
          Changed := true;
        end;
      end;
    end; {case}

    { Call the user-defined OnChange event }
    if Changed and Assigned(FOnItemChange) then
      FOnItemChange(Self, ActiveItem);
  end;
end;
{=====}

Modify the FocusCell procedure as follows...

{!!.02 - heavily modified}
procedure TO32CustomInspectorGrid.FocusCell(ACol, ARow: Longint; MoveAnchor: Boolean);
begin
  UpdateCellContents;
  MoveCurrent(ACol, ARow, MoveAnchor, True);
  DestroyEditor;
  UpdateEdit;
  Click;
  if Assigned(FOnItemSelect) then
    FOnItemSelect(Self, ActiveItem);
end;
{=====}

Modify the DoExit procedure as follows...

procedure TO32CustomInspectorGrid.DoExit;
begin
  UpdateCellContents;                                                 {!!.02}
  inherited DoExit;
  if not (goAlwaysShowEditor in Options) then HideEditor;
end;
{=====}


***********************************************************************
40.     OvcTable      enh  otoBrowseRow, disabled otoRowSize which
                           doesn't seem necessary
***********************************************************************
Change by commenting out otoNoColResing from the set of options applied
when otoBrowseRow is set.

procedure TOvcCustomTable.SetOptions(O : TOvcTblOptionSet);
  begin
    AllowRedraw := false;
    try
      FOptions := O;
      if HaveSelection then
        begin
          tbIsSelecting := false;
          tbIsDeselecting := false;
          tbSetAnchorCell(ActiveRow, ActiveCol, tstDeselectAll);
        end;
      {patch up the options set to exclude meaningless combinations}
      if (otoBrowseRow in FOptions) then
        begin
          FOptions := FOptions +
             [otoNoSelection, otoNoRowResizing{, otoNoColResizing}] - {!!.02}
             [otoMouseDragSelect, otoRowSelection, otoColSelection];
        end;
      if (otoAlwaysEditing in FOptions) then
        begin
          FOptions := FOptions +
             [otoNoSelection, otoNoRowResizing, otoNoColResizing] -
             [otoMouseDragSelect, otoRowSelection, otoColSelection];
        end
      else if (otoNoSelection in FOptions) then
        begin
          FOptions := FOptions -
             [otoMouseDragSelect, otoRowSelection, otoColSelection];
        end;
      if (otoRowSelection in FOptions) then
        FOptions := FOptions - [otoAllowRowMoves];
      if (otoColSelection in FOptions) then
        FOptions := FOptions - [otoAllowColMoves];
      InvalidateTable;
    finally
      AllowRedraw := true;
    end;{try..finally}
  end;
{--------}

***********************************************************************
41.     OvcRptVw      enh  New property, SortDirection on view fields
***********************************************************************
A new published property, SortDirection, has been introduced on view
fields. It controls how a view column behaves when its header is clicked
by the user.

Definition:

        property SortDirection: TOvcRvFieldSort

        where

        TOvcRvFieldSort = (rfsFirstAscending, rfsFirstDescending,
            rfsAlwaysAscending, rfsAlwaysDescending);

The values have the following meaning

  rfsFirstAscending:   The first time the column is clicked, the column
                       is sorted in ascending order. Subsequent clicks
                       on the same column toggles the sort order to
                       descending then back to ascending, and so on.

                       This is the default value.

  rfsFirstDescending:  The first time the column is clicked, the column
                       is sorted in descending order. Subsequent clicks
                       on the same column toggles the sort order to
                       ascending then back to descending, and so on.

  rfsAlwaysAscending:  The column is always sorted in ascending order.

  rfsAlwaysDescending: The column is always sorted in descending order.

A corresponding property, DefaultSortDirection, has been introduced at the
global field level to allow definition of a default value to be used for
user-defined views.

Note that these new properties only control what the user can do by clicking
a column header. It is still possible to set the sort order to contradict
the value of the SortDirection property via code. Also, the value of the
SortDirection property has no influence on the default sort column or direction
on the view. If you wish to use a non-default (column zero, ascending) sorting
the first time a view is displayed, you must still set the appropriate values
on the view definition.

Code modifications too involved to show here.

***********************************************************************
42.     O32IGrid      fix  ReadOnly property was left out of the
                           TO32InspectorItem
***********************************************************************
fix by modifying the TO32InspectorItem class as follows
(Note changes marked with {!!.02})...

  { InspectorItem }
  TO32InspectorItem = class(TO32CollectionItem)
  protected {private}
  << snip >>
    FImageIndex : Integer;
    FReadOnly   : Boolean;                                            {!!.02}
    FExpanded   : Boolean;
  << snip >>
    property Level: Integer read FLevel;
  published
    property Caption: string read FCaption write SetCaption;
    property ImageIndex: Integer read FImageIndex write FImageIndex;
    property ItemsList: TStringList read FItemsList write FItemsList; {!!.01}
    property ReadOnly: Boolean read FReadOnly write FReadOnly;        {!!.02}
    property ItemType: TO32IGridItemType read FType write SetType;
  {...}

and modify the TO32CustomInspectorGrid.CreateEditor procedure as follows...

function TO32CustomInspectorGrid.CreateEditor: TWinControl;
begin
  Result := nil;
  if TO32InspectorItem(FItems.VisibleItems[ActiveRow]).ReadOnly then  {!!.02}
    Exit;

  {...}

and modify the CanEditShow function as follows...

function TO32CustomInspectorGrid.CanEditShow: Boolean;
begin
  << snip >>
{!!.02}
  Result := not (TO32InspectorItem(FItems.VisibleItems[ActiveRow]).ItemType
    in [itParent, itSet])
     and not TO32InspectorItem(FItems.VisibleItems[ActiveRow]).ReadOnly;
{!!.02}
end;
{=====}


***********************************************************************
43.     OvcState      fix  If the storage hasn't been created yet, the
                           FormState assigns some default values to the
                           form, without regard to the state loaded
                           from the dfm.
***********************************************************************
Fix by exiting from ReadFormState if ReadState returns an empty string.
Modify ReadFormState as follows...

procedure TOvcFormState.ReadFormState(Form : TWinControl; const Section : string);
const
  Delims = [',', ' '];
var
  Placement : TWindowPlacement;
  WinState  : TWindowState;
  S         : string;
  X         : Integer;
  AForm     : TCustomForm;
begin
  if (Form is TCustomForm) then
    AForm := TCustomForm(Form)
  else
    Exit;

  << snip >>
          if rcNormalPosition.Right > rcNormalPosition.Left then
            SetWindowPlacement(Handle, @Placement);
        end;

      end                                                             {!!.02}
      else Exit;                                                      {!!.02}
    end;

    if (fsState in FOptions) then begin
      WinState := wsNormal;
{...}


***********************************************************************
44.     OvcDbTbl      fix  TOvcTCBaseEntryField descendants were not
                           being properly formatted in the table.
***********************************************************************
Fix by modifying the  TOvcCustomDbTable's Paint method as follows...

procedure TOvcCustomDbTable.Paint;
var
  R           : Integer;
  << snip >>

begin
  if InEditingState and (tbActiveCell is TOvcTCComboBox) then begin
    {validate area occupied by combobox}
  << snip >>

          {paint the cell}
          if Assigned(Fld) and Assigned(Cell) and (Cell is TOvcTCBitmap) then
          begin
            {if cell is a bitmap - handle specially}
            if not tbPaintBitmapCell(Canvas, DR, CellAttr, Fld, Cell,
  << snip >>
                  end else
                    raise;
                end;
              finally
                FreeMem(Data, DataSize);
              end;
            end else
              Cell.Paint(Canvas, DR, R, Col.Number, CellAttr, nil);
{!!.02 - begin}
          end else if Assigned(Fld) and Assigned(Cell)
          and (Cell is TOvcTCBaseEntryField) then begin
            DataSize := tbGetDataSize(Cell);
            if DataSize > 0 then begin

              {allocate data buffer}
              GetMem(Data, DataSize);
              try
                tbGetFieldValue(Fld, Cell, Data, DataSize);
                try
                  Cell.Paint(Canvas, DR, R, Col.Number, CellAttr, Data);
                except
                  on EInvalidPictureMask do begin
                    S := '********'; {invalid value for picturemask}
                    PaintString;
                  end else
                    raise;
                end;
              finally
                FreeMem(Data, DataSize);
              end;
            end else
              Cell.Paint(Canvas, DR, R, Col.Number, CellAttr, nil);
{!!.02 - end}
          end else
            PaintString;
        end;

        {draw the grid effects around the cell}
        DrawEffects(GridPen, TR);
  << snip >>
end;


***********************************************************************
45.     Many Files    fix  Hdc changed to TOvcHdc for BCB Compatibility
***********************************************************************
Note:  This fix requires many changes to many source files and is only 
recommended for those BCB users who are affected by the problem.  That 
is to say, only BCB users who are creating descendants of the affected 
classes.  This fix requires a rebould of all Orpheus packages and 
replacement of the BCB headers.

Now, On to the fix...
BCB treats an HDC as an Integer when it creates header files.  This 
causes problems when a user attempts to create descendant classes from 
Orpheus base classes in BCB.

The fix is to define TOvcHdc as an Integer when compiled under BCB and 
an Hdc when compiled under Delphi.  Every instance of an HDC being used 
in a parameter list must then be replaced with the new TOvcHdc.

Modify OvcMisc.pas as follows...
<< snip >>
interface

uses
  Windows, Buttons, Classes, Controls, ExtCtrls, Forms, Graphics, Messages,
  SysUtils, Consts, OvcData;

{ Hdc needs to be an Integer for BCB compatibility }                  {!!.02}
{$IFDEF CBuilder}                                                     {!!.02}
type                                                                  {!!.02}
  TOvcHdc  = Integer;                                                 {!!.02}
  TOvcHWND = Cardinal;                                                {!!.02}
{$ELSE}                                                               {!!.02}
type                                                                  {!!.02}
  TOvcHdc  = HDC;                                                     {!!.02}
  TOvcHWND = HWND;                                                    {!!.02}
{$ENDIF}                                                              {!!.02}                                                             {!!.02}

<< snip >>

{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
procedure TransStretchBlt(DstDC: TOvcHdc{HDC}; DstX, DstY, DstW, DstH: Integer;
                           SrcDC: TOvcHdc{HDC}; SrcX, SrcY, SrcW, SrcH: Integer;
                           MaskDC: TOvcHdc{HDC};
                           MaskX, MaskY : Integer);
<< snip >>

{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
procedure TransStretchBlt(DstDC: TOvcHdc{HDC}; DstX, DstY, DstW, DstH: Integer;
                           SrcDC: TOvcHdc{HDC}; SrcX, SrcY, SrcW, SrcH: Integer;
                           MaskDC: TOvcHdc{HDC};
                           MaskX, MaskY : Integer);
<< snip >>

{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
procedure DrawTransparentBitmapPrim(DC : TOvcHdc{HDC}; Bitmap : HBitmap;
  xStart, yStart, Width, Height : Integer; Rect : TRect;
  TransparentColor : TColorRef);
  {-draw transparent bitmap}
{...}

Modify OvcCmbx as follows...
  << snip >>
  TOvcBaseComboBox = class(TCustomComboBox)
  protected {private}
    {property variables}
  << snip >>
    procedure PaintBorders;

{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
    procedure PaintWindow(DC : TOvcHdc{HDC});
    {$IFDEF CBuilder} reintroduce; {$ELSE} override; {$ENDIF}
  << snip >>

{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
procedure TOvcBaseComboBox.PaintWindow(DC : TOvcHDC{Hdc});
begin
{...}

Modify Ovcef.pas as follows...
  << snip >> 
  {abstract entry field class}
  TOvcBaseEntryField = class(TOvcCustomControlEx)
   << snip >>

{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
    procedure efPaintPrim(DC : TOvcHDC{Hdc}; ARect : TRect; Offset : Integer);
      {-primitive routine to draw the entry field control}
  << snip >>

{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
procedure TOvcBaseEntryField.efPaintPrim(DC : TOvcHdc{Hdc};
  ARect : TRect; Offset : Integer);
  {-primitive routine to draw the entry field control}
var
{...}

Modify OvcLabel as follows...
<< snip >>

  TOvcCustomLabel = class(TCustomLabel)
  << snip >>
{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
    procedure PaintTo(DC : TOvcHdc{Hdc}; CR : TRect; Flags : Word);

  << snip >>

{!!.02 - Hdc changed to TOvcHdc for BCB compatibility}
procedure TOvcCustomLabel.PaintTo(DC : TOvcHdc {Hdc}; CR : TRect; Flags : Word);
begin
{...}

Modify OvcPlb as follows...
<< snip >>
uses
  Windows, Classes, Controls, Forms, Graphics, Menus, Messages, SysUtils,
  {$IFDEF VERSION6} Variants, {$ENDIF}
  OvcData, OvcIntl, OvcRLbl, OvcStr, OvcUser, OvcDate, OvcMisc;       {!!.02}
  << snip >>
type
  TOvcCustomPictureLabel = class(TOvcCustomRotatedLabel)
  << snip >>
{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
    procedure PaintTo(DC : TOvcHdc{hDC}; X, Y : Integer);
      virtual;

<< snip >>

{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
procedure TOvcCustomPictureLabel.PaintTo(DC : TOvcHdc{hDC}; X, Y : Integer);
var
{...}

Modify OvcRptvw as follows...
<< snip >>
{!!.02 - Hdc changed to TOvcHdc for BCB compatibility }
function GetRelativeAspect(PrinterDC : TOvcHdc{hDC}): double;
var
{...}


***********************************************************************
46.     Many Files    fix  HWnd changed to TOvcHWnd for BCB 
                           Compatibility
***********************************************************************
Note:  This fix requires many changes to many source files and is only 
recommended for those BCB users who are affected by the problem.  That 
is to say, only BCB users who are creating descendants of the affected 
classes.  This fix requires a rebould of all Orpheus packages and 
replacement of the BCB headers.

Now, On to the fix...
BCB treats an HWnd as an Integer when it creates header files.  This 
causes problems when a user attempts to create descendant classes from 
Orpheus base classes in BCB.

The fix is to define TOvcHWnd as an Integer when compiled under BCB and 
an HWnd when compiled under Delphi.  Every instance of an HWnd being 
used in a parameter list must then be replaced with the new TOvcHWnd.

Modify OvcMisc.pas as follows...
<< snip >>
interface

uses
  Windows, Buttons, Classes, Controls, ExtCtrls, Forms, Graphics, Messages,
  SysUtils, Consts, OvcData;

{ Hdc needs to be an Integer for BCB compatibility }                  {!!.02}
{$IFDEF CBuilder}                                                     {!!.02}
type                                                                  {!!.02}
  TOvcHdc  = Integer;                                                 {!!.02}
  TOvcHWND = Cardinal;                                                {!!.02}
{$ELSE}                                                               {!!.02}
type                                                                  {!!.02}
  TOvcHdc  = HDC;                                                     {!!.02}
  TOvcHWND = HWND;                                                    {!!.02}
{$ENDIF}                                                              {!!.02}                                                             {!!.02}
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
function GetNextDlgItem(Ctrl : TOvcHWnd{hWnd}) : hWnd;
  << snip >>
Implementation
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
function GetNextDlgItem(Ctrl : TOvcHWnd{hWnd}) : hWnd;
  {-Get handle of next control in the same form}
begin
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
function CheckTaskWindow(Window: TOvcHWnd{HWnd};
  Data: Longint): WordBool; stdcall;
begin
{...}

Modify O32FlxBn.pas as follows...
<< snip >>
uses
  Windows, Controls, Messages, Buttons, Graphics, Classes, OvcBase, OvcVer,
  Grids, StdCtrls{$IFDEF VERSION4}, O32MouseMon{$ENDIF}, OvcMisc;     {!!.02}
<< snip >>
  TO32CustomFlexButton = class(TBitBtn)
  protected {private}
  << snip >>
    {$IFDEF VERSION4}

{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility}
    procedure MouseMonitor(const MouseMessage: Integer;
                           const wParam, lParam: Integer;
                           const ScreenPt: TPoint;
                           const MouseWnd: TOvcHwnd{hWnd});
  << snip >>
{$IFDEF VERSION4}
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility}
procedure TO32CustomFlexButton.MouseMonitor(const MouseMessage: Integer;
                                            const wParam, lParam: Integer;
                                            const ScreenPt: TPoint;
                                            const MouseWnd: TOvcHWnd{hWnd});
var
{...}

Modify O32MouseMon.pas as follows...
<< snip >>
uses
  Windows, Classes, SysUtils, Messages, OvcMisc;                      {!!.02}
<< snip >>
type
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility}
  TMouseMonHandler = procedure(const MouseMessage, wParam, lParam: Integer;
    const ScreenPt: TPoint; const MouseWnd: TOvcHWnd{hWnd}) of object;

Modify OvcBase as follows...
<< snip >>
  TOvcController = class(TOvcComponent)
  protected {private}
  << snip >>
    FErrorText     : string;                 {text of last error}

{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
    FHandle        : TOvcHWnd{hWnd};         {our window handle}
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
    function GetHandle : TOvcHWnd{hWnd};
  << snip >>
  public 
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
    function IsSpecialButton(H : TOvcHWnd{hWnd}) : Boolean;
      dynamic;
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
    property Handle : TOvcHWnd{hWnd}
      read GetHandle;
  << snip >>
implementation
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
function TOvcController.GetHandle : TOvcHWnd{hWnd};
begin
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
function TOvcController.IsSpecialButton(H : TOvcHWnd{hWnd}) : Boolean;
begin
  << snip >>

Modify OvcCmbx.pas as follows...
  TOvcBaseComboBox = class(TCustomComboBox)
  protected {private}
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
    procedure CheckHot(HotWnd : TOvcHWnd{hWnd});
  << snip >>
  protected
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
    procedure ComboWndProc(var Message: TMessage;
      ComboWnd: TOvcHWnd{HWnd}; ComboProc: Pointer);
      {$IFDEF CBuilder} reintroduce; {$ELSE} override; {$ENDIF}
  << snip >>
Implementation
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
procedure TOvcBaseComboBox.CheckHot(HotWnd : TOvcHWnd{hWnd});
begin
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
procedure TOvcBaseComboBox.ComboWndProc(var Message: TMessage;
   ComboWnd: TOvcHWnd{HWnd}; ComboProc: Pointer);
begin
  if HotTrack and (Message.Msg = WM_NCHITTEST) then
    SetHot;
  {$IFDEF CBuilder}
  inherited ComboWndProc(Message, HWnd(ComboWnd), ComboProc);
  {$ELSE}
  inherited ComboWndProc(Message, ComboWnd, ComboProc);
  {$ENDIF}
end;
  {...}

Modify OvcDbTbl.pas as follows...
<< snip >>
  TOvcCustomDbTable = class(TOvcTableAncestor)
  protected {private}
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
    function tbEditCellHasFocus(FocusHandle : TOvcHWnd{hWnd}) : Boolean;
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
    function tbIsSibling(HW : TOvcHWnd{hWnd}) : Boolean;
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
    procedure tbSetFocus(AHandle : TOvcHWnd{hWnd});
  << snip >>
Implementation
  << snip >>

{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
function  TOvcCustomDbTable.tbEditCellHasFocus(
  FocusHandle : TOvcHWnd{hWnd}) : Boolean;
  {-return True if the edit cell has the focus}
var
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
function TOvcCustomDbTable.tbIsSibling(HW : TOvcHWnd{hWnd}) : Boolean;
  {-return True if the window HW one of our siblings}
var
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
procedure TOvcCustomDbTable.tbSetFocus(AHandle : TOvcHWnd{hWnd});
  {-call window's SetFocus routine}
begin
  {...}

Modify OvcEf.pas as follows...
<< snip >>
  TOvcBaseEntryField = class(TOvcCustomControlEx)
  {.Z+}
  protected {private}
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
    function  efIsSibling(HW : TOvcHWnd{hWnd}) : Boolean;
  << snip >>
Implementation
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
function TOvcBaseEntryField.efIsSibling(HW : TOvcHWnd{hWnd}) : Boolean;
  {-is the window HW one of our siblings}
var
{...}

Modify OVCTable.pas as follows...
<< snip >>
type
  TOvcCustomTable = class(TOvcTableAncestor)
    {-The custom class for tables}
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
      function  tbEditCellHasFocus(FocusHandle : TOvcHWnd{HWND}) : boolean;
  << snip >>
Implementation
  << snip >>
{!!.02 - HWnd changed to TOvcHWnd for BCB Compatibility }
function  TOvcCustomTable.tbEditCellHasFocus(
  FocusHandle : TOvcHWnd{HWND}) : boolean;
  var
  {...}



***********************************************************************
47.     OvcClrCb      fix  Colors weren't being displayed properly in
                           the dbColorComboBox.
***********************************************************************
Fix by adding a new function "ColorFromString" and modify a few other
procedures to use the new function as follows...

  TOvcCustomColorComboBox = class(TOvcBaseComboBox)
  protected {private}
  << snip >>
    procedure SetShowColorNames(Value : Boolean);
    function ColorFromString(Str: string): TColor;                    {!!.02}
  << snip >>
Implementation
  << snip >>

{!!.02 - modified}
procedure TOvcCustomColorComboBox.CreateWnd;
begin
  inherited CreateWnd;

  Text := '';
  Items.Clear;
  Items.Add(GetOrphStr(SCColorBlack));
  Items.Add(GetOrphStr(SCColorMaroon));
  Items.Add(GetOrphStr(SCColorGreen));
  Items.Add(GetOrphStr(SCColorOlive));
  Items.Add(GetOrphStr(SCColorNavy));
  Items.Add(GetOrphStr(SCColorPurple));
  Items.Add(GetOrphStr(SCColorTeal));
  Items.Add(GetOrphStr(SCColorGray));
  Items.Add(GetOrphStr(SCColorSilver));
  Items.Add(GetOrphStr(SCColorRed));
  Items.Add(GetOrphStr(SCColorLime));
  Items.Add(GetOrphStr(SCColorYellow));
  Items.Add(GetOrphStr(SCColorBlue));
  Items.Add(GetOrphStr(SCColorFuchsia));
  Items.Add(GetOrphStr(SCColorAqua));
  Items.Add(GetOrphStr(SCColorLightGray));
  Items.Add(GetOrphStr(SCColorMediumGray));
  Items.Add(GetOrphStr(SCColorDarkGray));
  Items.Add(GetOrphStr(SCColorWhite));
  Items.Add(GetOrphStr(SCColorMoneyGreen));
  Items.Add(GetOrphStr(SCColorSkyBlue));
  Items.Add(GetOrphStr(SCColorCream));

  ItemIndex := 0;
end;
  << snip >>

procedure TOvcCustomColorComboBox.DrawItem(Index : Integer; Rect : TRect;
                                 State : TOwnerDrawState);
var
  BC : TColor;
  S  : string;
begin
  {get selected color and text to display}
  if Index > -1 then begin
    S := Items[Index];
    BC := ColorFromString(S);                                         {!!.02}
  end else begin
    S := GetOrphStr(SCColorBlack);
    BC := clBlack;
  end;
  << snip >>

function TOvcCustomColorComboBox.GetSelectedColor : TColor;
begin
  if ItemIndex > -1 then
    Result := ColorFromString(Items[ItemIndex])                      {!!.02}
  else
    Result := clBlack;
end;

  << snip >>

procedure TOvcCustomColorComboBox.SetSelectedColor(Value : TColor);
var
  I : Integer;
begin
  for I := 0 to Pred(Items.Count) do
    if Value = ColorFromString(Items[I]) then begin                   {!!.02}
      ItemIndex := I;
      Change;
      Break;
    end;
end;

{!!.02 - New}
function TOvcCustomColorComboBox.ColorFromString(Str: string):TColor;
begin
  if Str = GetOrphStr(SCColorBlack) then result := clBlack
  else if Str = GetOrphStr(SCColorMaroon) then result := clMaroon
  else if Str = GetOrphStr(SCColorGreen) then result := clGreen
  else if Str = GetOrphStr(SCColorOlive) then result := clOlive
  else if Str = GetOrphStr(SCColorNavy) then result := clNavy
  else if Str = GetOrphStr(SCColorPurple) then result := clPurple
  else if Str = GetOrphStr(SCColorTeal) then result := clTeal
  else if Str = GetOrphStr(SCColorGray) then result := clGray
  else if Str = GetOrphStr(SCColorSilver) then result := clSilver
  else if Str = GetOrphStr(SCColorRed) then result := clRed
  else if Str = GetOrphStr(SCColorLime) then result := clLime
  else if Str = GetOrphStr(SCColorYellow) then result := clYellow
  else if Str = GetOrphStr(SCColorBlue) then result := clBlue
  else if Str = GetOrphStr(SCColorFuchsia) then result := clFuchsia
  else if Str = GetOrphStr(SCColorAqua) then result := clAqua
  else if Str = GetOrphStr(SCColorLightGray) then result := TColor($C0C0C0)
  else if Str = GetOrphStr(SCColorMediumGray) then result := TColor($A4A0A0)
  else if Str = GetOrphStr(SCColorDarkGray) then result := TColor($808080)
  else if Str = GetOrphStr(SCColorWhite) then result := clWhite
  else if Str = GetOrphStr(SCColorMoneyGreen) then result := TColor($C0DCC0)
  else if Str = GetOrphStr(SCColorSkyBlue) then result := TColor($F0CAA6)
  else if Str = GetOrphStr(SCColorCream) then result := TColor($F0FBFF)
  else result := clBlack;
end;
  {...}


***********************************************************************
48.     O32DbFe       fix  The dbFlexEdit wouldn't post changes to the
                           dataset if WantReturns or WordWrap were true.
***********************************************************************
Fix by moving Inherited to the end of the WMKillFocus procedure as
follows...

procedure TO32dbFlexEdit.WMKillFocus(var Msg : TWMKillFocus);
begin
  Exclude(fedbState, esFocused);

//inherited;                                                          {!!.02}

  if ValidateSelf and FDataLink.Editing then
    if Modified then fedbGetFieldValue;

  inherited;                                                          {!!.02}
end;
{=====}

***********************************************************************
49.     OvcOutln      enh  CacheSize property added
***********************************************************************
A new published CacheSize property was introduced. It allows the user to
customize the size of the node cache used to speed up painting and other
operations that need to locate outline nodes by their current vertical
offset in the outline. It's default size is 4096 entries. The value should
preferably be greater or equal to the highest number of visible nodes in
the outline.

***********************************************************************
50.     OvcEdit       fix  Bottom row drops below the bottom of the
                           editor.
***********************************************************************
Fix by modifying the following code in edCalcRowColInfo...


procedure TOvcCustomEditor.edCalcRowColInfo;
var
  Metrics : TTextMetric;
  OldRows : LongInt;
  OldCols : Integer;
begin
  {set canvas font to selected font}
  << snip >>

    {determine the number of rows}
    edRows := trunc(ClientHeight / edGetRowHt - 1);                  {!!.02}
{...}

Add the following code to the paint method...

procedure TOvcCustomEditor.Paint;
var
  < snip >

begin
  {get the client rectangle}
  << snip >>
  FarRt := FR.Right;

  { fix the bottom of the editor }                                    {!!.02}
  if (CR.Bottom - CR.Top > EdRows * EdGetRowHt) then                  {!!.02}
    Canvas.FillRect(Rect(Cr.Left, Cr.Top + EdRows * EdGetRowHt,       {!!.02}
      Cr.Right, Cr.Bottom));                                          {!!.02}

  {get colors}
{...}


***********************************************************************
51.     OvcEdit       fix  Flicker in the edit components.
***********************************************************************
Add the following code to the constructor...

constructor TOvcCustomTextFileEditor.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);

  {$IFDEF VERSION4}                                                   {!!.02}
  DoubleBuffered := true;                                             {!!.02}
  {$ENDIF}                                                            {!!.02}

  FBackupExt  := 'BAK';
  FIsOpen     := False;
  FMakeBackup := False;
end;

***********************************************************************
52.     OvcRvIdx      fix  Changed view not saved properly.
***********************************************************************

A previous column definition in a custom view layout wasn't being cleared
when the changed layout was saved. One effect was that it was impossible
to get rid of a previously active grouping attribute on a column.

To fix, make the following change:

procedure TOvcAbstractRvView.SaveToStorage(Storage: TOvcAbstractStore;
  const Prefix: string);
var
  i : Integer;
begin
  if FilterIndex <> -1 then
    Storage.WriteInteger(Prefix, 'FilterIndex', FilterIndex);
  if ViewFields.Count <> 0 then
    Storage.WriteInteger(Prefix, 'ViewFields', ViewFields.Count);
  for i := 0 to pred(ViewFields.Count) do begin
    Storage.EraseSection(Prefix + '_VF_' + IntToStr(i));               {!!.02}
    ViewField[i].SaveToStorage(Storage, Prefix + '_VF_' + IntToStr(i));
  end;
  if Tag <> 0 then
    Storage.WriteInteger(Prefix, 'Tag', Tag);
end;

***********************************************************************
53.     OvcRvIdx      enh  Indexer optimized when building grouped
                           views from scratch.
***********************************************************************
The report view indexer now uses a new, and much faster algorithm when
build indexes for grouped views that haven't been displayed before.

Too many changes to list here.

***********************************************************************
54.     OvcRptVw      fix  Custom views could not be deleted
***********************************************************************
Custom view layouts that were deleted by the user would still be present
in the next session if deleting the view was the only change the user
made. The reason was that the dirty state was kept on view definitions only.

To fix, make the following changes:

Add a new field, ViewDeleted, to the definition for TOvcCustomReportView:

    ViewDeleted              : Boolean;                                {!!.02}

then, change TOvcRVView.Destroy as follows:

destructor TOvcRVView.Destroy;
var
  SaveOwner : TOvcCustomReportView;
begin
  if Owner <> nil then                                                   {!!.02}
    if not (csDestroying in Owner.ComponentState) then                   {!!.02}
      if FDFMBased then                                                  {!!.02}
        raise Exception.Create('Default view. May not be deleted');      {!!.02}
  if (Owner <> nil)                                                      {!!.02}
  and ([csDesigning, csDestroying] * Owner.ComponentState = [])          {!!.02}
  and not FDFMBased then                                                 {!!.02}
    TOvcCustomReportView(Owner).ViewDeleted := True;                     {!!.02}
  {$IFDEF Version5}
  if csAncestor in ComponentState then
  ....

then, change TOvcCustomReportView.SaveDirtyViews as follows:

procedure TOvcCustomReportView.SaveDirtyViews;
var
  i, c: Integer;
  FieldKey, ViewKey : string;
  AnyDirty: Boolean;
begin
  if csDesigning in ComponentState then
    exit;
  AnyDirty := False;
  for i := 0 to Fields.Count - 1 do
    if Field[i].Dirty then begin
      AnyDirty := True;
      break;
    end;
  if ViewDeleted then                                                  {!!.02}
    AnyDirty := True                                                   {!!.02}
  else                                                                 {!!.02}
  if not AnyDirty then
    for i := 0 to Views.Count - 1 do
      if View[i].Dirty then begin
        AnyDirty := True;
        break;
      end;
  if not AnyDirty then
    exit;

***********************************************************************
55.     OvcViewEd     enh  Field panels changed to scroll boxes
***********************************************************************
In the custom view layout editor, the panels used for fields has been
changed from panels to scroll boxes to allow them to hold more fields
than will fit in the visible area of the panels.



***********************************************************************
56.     OvcTCHdr      fix  Table Header Cell component doesn't respect
                           color and font settings.
***********************************************************************
Modify the tcPaint method as follows (Note changes marked with {!!.02}).

procedure TOvcTCColHead.tcPaint(TableCanvas : TCanvas;
                          const CellRect    : TRect;
                                RowNum      : TRowNum;
                                ColNum      : TColNum;
                          const CellAttr    : TOvcCellAttributes;
                                Data        : pointer);
  {------}
  procedure PaintAnArrow;
    var
      ArrowDim : Integer;
      X, Y     : Integer;
      LeftPoint, RightPoint, BottomPoint : TPoint;
      CellWidth  : integer;
      CellHeight : integer;
    begin
      CellWidth := CellRect.Right - CellRect.Left;
      CellHeight := CellRect.Bottom - CellRect.Top;
      with TableCanvas do
        begin
          Pen.Color := CellAttr.caFont.Color;
          Brush.Color := Pen.Color;
          ArrowDim := MinI(CellWidth, CellHeight) div 3;
          case CellAttr.caAdjust of
            otaTopLeft, otaCenterLeft, otaBottomLeft:
              X := Margin;
            otaTopRight, otaCenterRight, otaBottomRight:
              X := CellWidth-Margin-ArrowDim;
          else
            X := (CellWidth - ArrowDim) div 2;
          end;{case}
          inc(X, CellRect.Left);
          case CellAttr.caAdjust of
            otaTopLeft, otaTopCenter, otaTopRight:
              Y := Margin;
            otaBottomLeft, otaBottomCenter, otaBottomRight:
              Y := CellHeight-Margin-ArrowDim;
          else
            Y := (CellHeight - ArrowDim) div 2;
          end;{case}
          inc(Y, CellRect.Top);
          LeftPoint := Point(X, Y);
          RightPoint := Point(X+ArrowDim, Y);
          BottomPoint := Point(X+(ArrowDim div 2), Y+ArrowDim);
          Polygon([LeftPoint, RightPoint, BottomPoint]);
        end;
    end;
  {------}
  var
    DataSt    : POvcShortString absolute Data;
    LockedCols: TColNum;
    ActiveCol : TColNum;
    WorkCol   : TColNum;
    C         : string[1];
    HeadSt    : ShortString;
    CA        : TOvcCellAttributes;                                   {!!.02}
  begin
    CA := CellAttr;                                                   {!!.02}
    if Assigned(FTable) then
      begin
        LockedCols := tcRetrieveTableLockedCols;
        ActiveCol := tcRetrieveTableActiveCol;
      end
    else
      begin
        LockedCols := 0;
        ActiveCol := -1;
      end;
    HeadSt := '';
    { Set the cell color and font }                                   {!!.02}
    if not TableColor then                                            {!!.02}
      CA.caColor := Color;                                            {!!.02}
    if not TableFont then                                             {!!.02}
      CA.caFont.Assign(Font);                                         {!!.02}
      CA.caFontColor := Font.Color;                                   {!!.02}
    { if required show a down arrow for the active column }
    if ShowActiveCol and (ColNum = ActiveCol) then
      begin
        {this call to inherited tcPaint blanks out the cell}
        inherited tcPaint(TableCanvas, CellRect, RowNum, ColNum, CA,  {!!.02}
          @HeadSt);                                                   {!!.02}
        PaintAnArrow;
      end
    else if ShowLetters then
      begin
        {convert the column number to the spreadsheet-style letters}
        WorkCol := ColNum - LockedCols + 1;
        HeadSt := '.';
        while (WorkCol > 0) do
          begin
            C := AnsiChar(pred(WorkCol) mod 26 + ord('A'));
            System.Insert(C, HeadSt, 1);
            WorkCol := pred(WorkCol) div 26;
          end;
        Delete(HeadSt, length(HeadSt), 1);
        inherited tcPaint(TableCanvas, CellRect, RowNum, ColNum, CA,  {!!.02}
          @HeadSt);                                                   {!!.02}
      end
    else {Data points to a column heading}
      begin
        if Assigned(Data) then
          HeadSt := DataSt^
        else if (0 <= ColNum) and (ColNum < Headings.Count) then
          HeadSt := Headings[ColNum];
        inherited tcPaint(TableCanvas, CellRect, RowNum, ColNum, CA,  {!!.02}
          @HeadSt);                                                   {!!.02}
      end;
  end;
{--------}

***********************************************************************
57.     ovcstore      fix  Couldn't update any tags after an emtpy value
                           had been saved.
***********************************************************************
Modify WriteString as follows...

procedure TO32XMLFileStore.WriteString(const Section, Item, Value : string);
var
  ItemList, ElementName : string;
  << snip >>
begin
  ItemList := Item;

<< snip >>
            { if the tag currently has no value then make sure it doesn't have }
            { any children.}
            if TElement(xsElementList.Items[Temp]).Value = '' then begin
              EndingTagLoc := xsFindClosingTag(Temp);
              { if it's a compound tag with no children then we can delete the }
              { closing tag and update it without any problems }
              if EndingTagLoc = Temp + 1 then begin
                { It's a parent tag with no children so we can delete its }
                { closing tag and update it }
                xsAdjustParentIndex(EndingTagLoc, false);
                xsDeleteFromElementList(EndingTagLoc);
                TElement(xsElementList.Items[Temp]).Value := Value
{!!.02}       end else if (EndingTagLoc = Temp) or (EndingTagLoc = -1) then
                { It is a regular tag that just happens to have an empty value }
                { so go ahead and update it }
                TElement(xsElementList.Items[Temp]).Value := Value
            end else
              TElement(xsElementList.Items[Temp]).Value := Value
<< snip >>
end;
{=====}

***********************************************************************
58.     OvcMeter      enh  OwnerDraw event added to the OvcMeter.
***********************************************************************

Modify the OvcMeter.pas file as follows...

{*********************************************************}
{*                  OVCMETER.PAS 4.01                    *}
{*     Copyright (c) 1995-2001 TurboPower Software Co    *}
{*                 All rights reserved.                  *}
{*********************************************************}

(*Changes)
{!!.02}
  01/11/02- OwnerDraw event added.
*)

{$I OVC.INC}

<< snip >>

uses
  Windows, Classes, Controls, Graphics, Forms, Messages, SysUtils, OvcBase,
  OvcMisc, ExtCtrls;

type
  {!!.02}
  TOvcOwnerDrawMeterEvent = procedure(Canvas: TCanvas; Rec: TRect) of object;

  TMeterOrientation = (moHorizontal, moVertical);

type
  TOvcCustomMeter = class(TOvcGraphicControl)
  protected {private}
    {Property fields}
<< snip >>
    FUsedImage     : TBitmap;
    FOwnerDraw     : TOvcOwnerDrawMeterEvent;                         {!!.02}

    MemBM          : TBitMap;
    TxtBM          : TBitMap;
<< snip >>
  public
    {VCL methods}
    constructor Create(AOwner : TComponent);
      override;
    destructor Destroy;
      override;
<< snip >>
    property Percent : Integer
      read FPercent write SetPercent;
    property OnOwnerDraw: TOvcOwnerDrawMeterEvent                     {!!.02}
      read FOwnerDraw write FOwnerDraw;                               {!!.02}
  end;
<< snip >>

  TOvcMeter = class(TOvcCustomMeter)
  published
    property BorderStyle;
<< snip >>
    property Visible;

    {inherited events}
    property OnClick;
    property OnDblClick;
    property OnMouseDown;
    property OnMouseMove;
    property OnMouseUp;
    property OnOwnerDraw;                                             {!!.02}
  end;

<< snip >>

procedure TOvcCustomMeter.Paint;
var
  ClRect, R  : TRect;
<< snip >>
begin
  if (MemBM <> nil) and ((MemBM.Width <> ClientWidth)
  or (MemBM.Height <> ClientHeight)) then begin
    MemBM.Free;

<< snip down to the end of the procedure >>

        inc(R.Top, 2);
        TextHt := TextHeight(ValueString);
        TextWd := TextWidth(ValueString);
        TextOut(ClRect.Left + (ClWidth - TextWd) div 2,
          ClRect.Top + (ClHeight - TextHt) div 2, ValueString);
      end;
    end;
  end
  else if Assigned(OnOwnerDraw) then                                  {!!.02}
    OnOwnerDraw(MemBM.Canvas, Rect(0, 0, Width, Height));             {!!.02}


  Canvas.CopyMode := cmSrcCopy;
  Canvas.Draw(0, 0, MemBM);
end;

***********************************************************************
59.     O32Igrid      fix  Pressing enter while editing a string field,
                           marked the data as unchanged.
***********************************************************************
Modify the TO32GridEdit's KeyDown procedure as follows...

procedure TO32GridEdit.KeyDown(var Key: Word; Shift: TShiftState);

  procedure SendToParent;
  begin
  << snip >>

begin
  { translate the enter key to mean arrow down }
  if Key = VK_RETURN then Key := VK_DOWN;                             {!!.02}

  case Key of
    VK_UP, VK_DOWN, VK_PRIOR, VK_NEXT, VK_ESCAPE: SendToParent;
    VK_INSERT:

<< snip >>


***********************************************************************
60.     O32IGrid      fix  Using the ItemCollection property editor
                           caused an error in Delphi.
***********************************************************************
Changes too numerous to list.


***********************************************************************
61.     ovcsc         fix  OvcSpinner would deadlock at initialization.
***********************************************************************
Modify SetAutoRepeat to prevent AutoRepeat from occurring when the
component is loaded from the DFM.

procedure TOvcSpinner.SetAutoRepeat(Value: Boolean);
begin
  FAutoRepeat := Value;
  if FAutoRepeat and not (csLoading in ComponentState) then           {!!.02}
    scDoAutoRepeat;
end;

***********************************************************************
62.     ovccmbx       fix  Could not reload internal MRUList
***********************************************************************
The MRUListCount property sets the same value for both the MRUList's
"Max Item Count" as well as the real "Item Count", which is screwy.

As I am loathe to break an implemented and deployed interface, I had to
create a new methos called ForceItemsToMRUList, which removes 'X' number
of items from the top of the combo box's items, and forcibly moves them
to the MRU list.  If an item isn't a duplicate in the list, then it is
ignored.

Modify OvcCmbx as follows {Note changes marked with !!.02}...

{...}
  TOvcBaseComboBox = class(TCustomComboBox)
  protected {private}
    {property variables}
    FAutoSearch   : Boolean;
  << snip >>
    procedure SetListIndex(Value: Integer);
    function  GetList : TStrings;
    function GetMRUList: TStrings;                                    {!!.02}
    procedure SetKeyDelay(Value : Integer);
  << snip >>
    procedure RemoveItem(const Item : string);

    procedure ClearMRUList;
    procedure ForceItemsToMRUList(Value: Integer);                    {!!.02}

    property AttachedLabel : TOvcAttachedLabel
      read GetAttachedLabel;
  << snip >>
    property ListIndex: Integer
      read GetListIndex write SetListIndex;

    property MRUList: TStrings                                        {!!.02}
      read GetMRUList;                                                {!!.02}

    property StandardHomeEnd : Boolean
      read FStandardHomeEnd write SetStandardHomeEnd;
 << snip >>
procedure TOvcBaseComboBox.ClearMRUList;
var
  I : Integer;
begin
  if (FMRUList.Items.Count > 0) then begin
    for I := 1 to FMRUList.Items.Count do
      if (I <= Items.Count) then
        Items.Delete(0);
    FMRUList.Clear;
  end;
end;

{!!.02 - added}
procedure TOvcBaseComboBox.ForceItemsToMRUList(Value: Integer);
var
  I, J: Integer;
  Str: string;
begin
  if (Value > 0) or (Value <= FMRUList.MaxItems) then begin
    for I := 0 to pred(Value) do begin
      Str := Items.Strings[I];
      J := I + 1;
      while (J < Items.Count) and (Items.Strings[J] <> Str) do
        Inc(J);
      if (J < Items.Count) then begin
        Items.Delete(I);
        AddItemToMRUList(J - 1);
      end;
    end;
  end;

  UpdateMRUList;
end;

<< snip >>

function TOvcBaseComboBox.GetList : TStrings;
var
  I : Integer;
begin
  FList.Clear;
  FList.Assign(Items);
  if FMRUList.Items.Count > 0 then
    for I := 0 to Pred(FMRUList.Items.Count) do
      FList.Delete(0);
  Result := FList;
end;

{!!.02 - Added}
function TOvcBaseComboBox.GetMRUList: TStrings;
begin
  result := FMRUList.FList;
end;

procedure TOvcBaseComboBox.SetListIndex(Value : Integer);
{...}


***********************************************************************
63.     OvcDbPf       enh  Added support for the new DbExpress
                           TimeStamp field type to the
                           OvcDbPictureField.
***********************************************************************
Modified OvcDbPf as follows...

Note: DbExpress is ugly buggy.

const
  {field types supported by the data aware picture field}
  SupportedFieldTypes : set of  TFieldType =
    [ftString, ftSmallInt, ftInteger, ftWord, ftBoolean,
     ftFloat, ftCurrency, ftDate, ftTime, ftDateTime, ftBCD
     {$IFDEF VERSION5}, ftWideString {$ENDIF}
     {$IFDEF VERSION6}, ftTimeStamp {$ENDIF}];                        {!!.02}
  << snip >>
procedure TOvcDbPictureField.pfdbGetFieldValue;
var
  S  : string[MaxEditLen];
  << snip >>
begin
  {if the field contents are invalid, exit}
  if not Controller.ErrorPending then {avoid multiple error reports}
  << snip >>
        ftCurrency   : Field.AsFloat := E;
        ftBCD        : Field.AsFloat := E;

        ftDate, ftTime {$IFDEF VERSION6} , ftTimeStamp {$ENDIF}       {!!.02}
                     : Field.AsDateTime := DT;                        {!!.02}

        ftDateTime   :
  << snip >>
procedure TOvcDbPictureField.pfdbSetFieldProperties;
begin
  case FFieldType of
  << snip >>
    ftCurrency : DataType := pftExtended;
    ftBCD      : DataType := pftExtended;
    ftDate     : DataType := pftDate;
    ftTime     : DataType := pftTime;
    ftDateTime {$IFDEF VERSION6} , ftTimeStamp {$ENDIF} :             {!!.02}
      case DateOrTime of
        ftUseDate, ftUseBothEditDate : DataType := pftDate;
        ftUseTime, ftUseBothEditTime : DataType := pftTime;
      end;
  << snip >>

procedure TOvcDbPictureField.pfdbSetFieldValue;
var
  S  : string[MaxEditLen];
  << snip >>
begin
  if efdbBusy then
    Exit;

  << snip >>
      ftBCD      : E := Field.AsFloat;
      ftTime     : if (Field.IsNull) then
                     DT := BadTime
                   else
                     DT := Field.AsDateTime;
      ftDate,
      ftDateTime {$IFDEF VERSION6} , ftTimeStamp {$ENDIF}:            {!!.02}
        if (Field.IsNull) then DT := BadDate
        else DT := Field.AsDateTime;
  << snip >>


***********************************************************************
64.     O32FlxEd      fix  Changing alignment caused the text to
                           disappear.
***********************************************************************
Changing the alignment on the FlexEdit caused the text to disappear.

The FlexEdit's multi-line behaviour was modeled after the TMemo.  While
investigating this problem, I noticed that the TMemo also doesn't work
properly.

The fix is to remove the overloaded WMPaint procedure and modify the
SetAlignment procedure to temporarily store the text while changing
alignment.

Comment out the WMPaint reference...

{!!.02 - Not necessary}
    {procedure WMPaint      (var Message : TWMPaint);      message WM_PAINT;}

Comment out the WMPaint implementation...

{!!.02 - Not necessary }
(*
procedure TO32CustomFlexEdit.WMPaint(var Message: TWMPaint);
var
  Rct: TRect;
  Str: string;
  DC: HDC;
  PS: TPaintStruct;
begin
  if (FUpdating > 0) then exit;

  if ((FAlignment = taLeftJustify ) or Focused)
    and not (csPaintCopy in ControlState)
  then inherited
  else begin
    DC := Message.DC;
    if DC = 0 then DC := BeginPaint(Handle, PS);
    FCanvas.Handle := DC;
    try
      if (FAlignment = taRightJustify) then begin
        FCanvas.Font := Font;
        with FCanvas do begin
          Rct := ClientRect;
          Brush.Color := Color;
          Str := Text;
          TextRect(Rct, Rct.Right - TextWidth(Str) - 2, 2, Str);
        end;
      end;
    finally
      FCanvas.Handle := 0;
      if Message.DC = 0 then EndPaint( Handle, PS );
    end;
  end;
end;
{=====}
*)

Modify the SetAlignment procedure as follows....

{!!.02 - rewritten to solve the "Text disappearing at alignment change" bug. }
procedure TO32CustomFlexEdit.SetAlignment(Value: TAlignment);
var
  Str: string;
begin
  if FAlignment <> Value then
  begin
    Str := Text;
    FAlignment := Value;
    RecreateWnd;
    Text := Str;
  end;
end;
{=====}


***********************************************************************
65.     O32SBar       enh  Modified FixControls for optimization.
***********************************************************************
Modify FixControls as follows...

{!!.02 - rewritten for optimization}
procedure TO32SBContainer.FixControls;
var
  Control    : TControl;
  I          : Integer;
begin
  if FStatusBar = nil then exit;

  {Set component height to that of the container}
  for I := 0 to ComponentCount - 1 do begin
    Control := nil;
    try
      {Ignore non-visual controls...}
      if Components[I] is TCustomEdit then begin
        Control := TCustomEdit(Components[I]);
        ProtectedEdit(Components[I]).AutoSize := false;
        ProtectedEdit(Components[I]).BorderStyle := bsNone;
      end else
      if Components[I] is TControl then
        Control := TControl(Components[I])
      else
      if Components[I] is TGraphicControl then
        Control := TGraphicControl(Components[I]);
      if Control <> nil then begin
        {Resize TControls as necessary}
        Control.Height := Self.Height;
        Control.Top := 0;
      end;
    except
      {swallow exceptions}
    end;
  end;
end;
{=====}


***********************************************************************
66.     OvcEditP      fix  The OvcTextFileEditor displays the control
                           character for a carriage return (#13).
***********************************************************************
Fix by adding a test for #13 and subsequent code to strip them out.
Modify TOvcParaList.InsertBlock as follows (Note changes marked with
{!!.03})...

function TOvcParaList.InsertBlock(Editor : TOvcEditBase; var P : LongInt;
                               var Pos : Integer; S : PAnsiChar) : Word;
  {-insert a block of text}
var
  L, Len, Max : Word;
  I, J, OPos : Integer;                                               {!!.03}
  temp: string;                                                       {!!.03}
  SaveLinking : Boolean;
  OP : LongInt;
begin
  Max := StrLen(S);
  Len := edScanToEnd(S, Max);
  L := Len;
  << snip >>
    UndoBuffer.BeginComplexOp(SaveLinking);
    while (Result = 0) and (S^ <> #0) do begin

      { strip cr from block }                                         {!!.03}
      temp := S;                                                      {!!.03}
      while (System.Pos(#13, temp) > 0) do                            {!!.03}
        Delete(temp, System.Pos(#13, temp), 1);                       {!!.03}
      S := PChar(temp);                                               {!!.03}

      if (Len > L) and (Pos = 1) then
        Result := InsertParaPrim(Editor, P, S, L)
  << snip >>
end;


***********************************************************************
67.     OvcURL        enh  Added an UnderlineURL property.
***********************************************************************
Note: This modification afects designtime behaviour so the Orpheus
packages will have to be rebuilt in order to see the change at
designtime.

Modify OvcURL.Pas as follows (Note changes marked with {!!.03})...

type
  TOvcURL = class(TCustomLabel)
  protected {private}
    FCaption         : string;
    FHighlightColor  : TColor;
    FURL             : string;
    FUseVisitedColor : Boolean;
    FVisitedColor    : TColor;

    {internal variables}
    urlTimer         : TTimer;
    urlFontColor     : TColor;

    {property methods}
    function GetAbout : string;
    function GetUnderlineURL: Boolean;                                {!!.03}
    procedure SetAbout(const Value : string);
    procedure SetCaption(const Value : string);
    procedure SetHighlightColor(const Value : TColor);
    procedure SetUnderlineURL(Value: Boolean);                        {!!.03}
    procedure SetURL(const Value : string);
    procedure SetVisitedColor(const Value : TColor);

  << snip >>

  published
    property About : string
      read GetAbout write SetAbout stored False;
    property Caption : string
      read FCaption write SetCaption;
    property HighlightColor : TColor
      read FHighlightColor write SetHighlightColor;
    property UnderlineURL: Boolean                                    {!!.03}
      read GetUnderlineURL write SetUnderlineURL;                     {!!.03}
    property URL : string
      read FURL write SetURL;

  << snip >>

{*** TOvcURL ***}
procedure TOvcURL.Loaded;
begin
  inherited Loaded;

//  Font.Style := Font.Style + [fsUnderline];                         {!!.03}
  urlFontColor := BadColor;
end;

<< snip >>

constructor TOvcURL.Create(AOwner : TComponent);
{$IFDEF TRIALRUN}
var
  X : Integer;
{$ENDIF}
begin
  inherited Create(AOwner);
  FHighlightColor := clRed;
  Cursor := crHandPoint;
  Font.Style := Font.Style + [fsUnderline];                           {!!.03}
{$IFDEF TRIALRUN}
  X := _CC_;
  if (X < ccRangeLow) or (X > ccRangeHigh) then Halt;
  X := _VC_;
  if (X < ccRangeLow) or (X > ccRangeHigh) then Halt;
{$ENDIF}
end;

  << snip >>

{!!.03 - added}
procedure TOvcURL.SetUnderlineURL(Value: Boolean);
begin
  if Value then
    Font.Style := Font.Style + [fsUnderline]
  else
    Font.Style := Font.Style - [fsUnderline];
end;



***********************************************************************
68.     O32FlxEd      fix  AutoSelect did not work.
***********************************************************************
Modify CMGotFocus as follows...

procedure TO32CustomFlexEdit.CMGotFocus(var Message : TMessage);
begin
  inherited;
  if Enabled and MultiLineEnabled then begin
    if FDisplayedLines <> FEditLines.FocusedLines then begin
      SetDisplayedLines(FEditLines.FocusedLines);
      AdjustHeight;
    end;
  end;
  if AutoSelect then                                                  {!!.03}
    SelectAll;                                                        {!!.03}
  SaveEditString;
end;
{=====}

***********************************************************************
69.     O32FlxEd      fix  FlexEdit is not respecting the
                           efColors.disabled color settings.
***********************************************************************
This is a partial fix as the ancestor is still overriding the font color
when the control is disabled.

Modify O32FlxEd.pas as follows...

  TO32CustomFlexEdit = class(TO32CustomEdit)
  protected {private}
    FAlignment        : TAlignment;

    << snip >>

    {Internal Variables}
    FSaveEdit        : String;     {saved copy of edit string}
    FCreating        : Boolean;

    FSavedColor      : TColor;                                        {!!.03}
    FSavedFontColor  : TColor;                                        {!!.03}

    FUpdating        : Integer;

   << snip >>

{!!.03 - was commented out in 4.02}
    procedure WMPaint      (var Message : TWMPaint);      message WM_PAINT;

  << snip >>

{===== TO32CustomFlexEdit ============================================}
constructor TO32CustomFlexEdit.Create(AOwner : TComponent);
begin
  FCreating := True;

  << snip >>

  Height := 80;
  AdjustHeight;

  Validation := TFlexEditValidatorOptions.Create(self);
  FSavedColor := Color;                                               {!!.03}
  FSavedFontColor := Font.Color;                                      {!!.03}
  FCreating := False;
end;
{=====}

  << snip >>

{WMPaint had been completely commented out in 4.02.  It is now }
{ re introduced as follows.... }
{!!.03 - Re-written}
procedure TO32CustomFlexEdit.WMPaint(var Message: TWMPaint);
begin
  { known limitation, The ancestor is overriding the font color when the }
  { control is disabled }
  if not Enabled then begin
    Color := efColors.Disabled.BackColor;
    Font.Color := efColors.Disabled.TextColor;
  end else begin
    Color := FSavedColor;
    Font.Color := FSavedFontColor;
  end;
  inherited;
end;
{...}


***********************************************************************
70.     OvcTable      fix  Longstanding Scroll Range Bug.
***********************************************************************
Modify tbSetScrollRange as follows (Changes marked with {!!.03})...

procedure TOvcCustomTable.tbSetScrollRange(SB : TOvcScrollBar);
  var
    Divisor : LongInt;
  begin
    if (SB = otsbVertical) then
      begin
        if HandleAllocated then                                       {!!.03}
          tbCalcRowsOnLastPage;                                       {!!.03}
        if tbHasVSBar and HandleAllocated then
          begin
//            tbCalcRowsOnLastPage;                                   {!!.03}
            if (tbLastTopRow < 16*1024) then
              if tbCalcRequiresVSBar then
{...}


***********************************************************************
71.     O32IGrid      fix  Logical item type creates more than one pair
                           of True/False selections.
***********************************************************************
Modify SetType as follows (Changes marked with {!!.03})...

procedure TO32InspectorItem.SetType(Value: TO32IGridItemType);
begin
  if Value <> FType then begin
    FType := Value;
    case FType of
        {itParent    :}
        {itSet       :}
        {itList      :}
        {itString    :}
        {itInteger   :}
        {itFloat     :}
        {itCurrency  :}
        itDate      : FDate := now;
        itColor     : FColor := clBlack;
        itLogical   : begin
          if FItemsList.count = 0 then begin                          {!!.03}
            FItemsList.Add('True');
            FItemsList.Add('False');
          end;                                                        {!!.03}
          AsString := 'true';
        end;
        itFont      : FFont.Assign(FIGrid.Font);
    end;
    FIGrid.ItemChanged(Self);
  end;
end;
{=====}


***********************************************************************
72.     OvcRptVw      fix  Printing does not respect the value of the
                           Visible property on view fields
***********************************************************************
In OvcRptVw.pas, apply the following {!!.03} marked changes:

procedure TOvcCustomReportView.DoSectionHeader(Canvas: TCanvas; var CurY: Integer; LineHeight, VPage,
  PrintStartLeft: Integer);
var
  CurX, i, LocalLineHeight : Integer;
begin
  if HeaderImages <> nil then
    LocalLineHeight := MaxI(LineHeight, round((HeaderImages.Height + 2) * PAspect))
  else
    LocalLineHeight := LineHeight;
  if IsGrouped then
    Canvas.Font.Style := [fsBold];
  inc(CurY, LocalLineHeight); {blank line}
  CurX := PrintStartLeft;
  for i := 0 to pred(CurrentView.GroupCount) do begin
    with CurrentView.ViewField[i], Field do
      if Visible then                                                {!!.03}
        if (FVPage = VPage) or (FVPage = -1) then
          CurX := PaintCell(Canvas, CurY, nil, '',CurrentView.ViewField[i],
            CurX, False, False, True, True, i = pred(CurrentView.GroupCount), -1, LocalLineHeight);
  end;
  for i := CurrentView.GroupCount to pred(CurrentView.ViewFields.Count) do
    with CurrentView.ViewField[i], Field do
      if Visible then                                                {!!.03}
        if (FVPage = VPage) or (FVPage = -1) then begin
          CurX := PaintCell(Canvas, CurY, nil, Caption, CurrentView.ViewField[i], CurX,
            True, False, True, True, i = pred(CurrentView.ViewFields.Count), ImageIndex, LocalLineHeight);
        end;
  inc(CurY, LocalLineHeight);
  if IsGrouped then
    Canvas.Font.Style := [];
end;

procedure TOvcCustomReportView.DoLine(Canvas: TCanvas; var CurY: Integer; LineHeight, VPage: Integer;
  Line, PrintStartLeft : Integer);
var
  CurX,i,Gr : Integer;
  S : string;
  Data : Pointer;
begin
  CurX := PrintStartLeft;
  if not IsGroup[Line] then begin
    Data := ItemData[Line];
    for i := 0 to pred(CurrentView.GroupCount) do
      with CurrentView.ViewField[i],Field do
        if Visible then                                                {!!.03}
          if (FVPage = VPage) or (FVPage = -1) then
            CurX := PaintCell(Canvas, CurY, Data, '', CurrentView.ViewField[i], CurX, False,
             False, False, True, i = pred(CurrentView.GroupCount), -1, LineHeight);
    for i := CurrentView.GroupCount to pred(CurrentView.ViewFields.Count) do
      with CurrentView.ViewField[i],Field do
        if Visible then                                                {!!.03}
          if (FVPage = VPage) or (FVPage = -1) then begin
            S := '';
            if (Data <> nil) then
              S := AsString(Data);
            CurX := PaintCell(Canvas, CurY, Data, S, CurrentView.ViewField[i], CurX, False,
              False, True, True, i = pred(CurrentView.ViewFields.Count), -1, LineHeight);
          end;
  end else begin
    Canvas.Font.Style := [fsBold];
    Data := ItemData[Line];
    Gr := GroupField[Line];
    if VPage = 0 then
      for i := 0 to pred(CurrentView.GroupCount) do begin
        if CurrentView.ViewField[i].Visible then begin                 {!!.03}
          S := CurrentView.ViewField[i].Field.Caption;
          if S <> '' then
            S := S + ' : ';
          S := S + CurrentView.ViewField[i].Field.AsString(Data);
          CurX := PaintCell(Canvas, CurY, Data{nil}, S, CurrentView.ViewField[i], CurX, False,
            False, i = Gr, False, i = pred(CurrentView.GroupCount), -1, LineHeight);
        end;                                                           {!!.03}
      end;
    if CurrentView.ShowGroupTotals then begin
      for i := CurrentView.GroupCount to pred(CurrentView.ViewFields.Count) do
        with CurrentView.ViewField[i], Field do begin
          if Visible then begin                                        {!!.03}
            if (FVPage = VPage) or (FVPage = -1) then
              if ComputeTotals then
                S := DoGetGroupString(CurrentView.ViewField[i], GroupRef[Line])
              else
                S := '';
              CurX := PaintCell(Canvas, CurY, nil, S,CurrentView.ViewField[i], CurX,
                False, False, ComputeTotals,
                True, i = pred(CurrentView.ViewFields.Count), -1, LineHeight);
          end;                                                         {!!.03}
        end;
    end;
    Canvas.Font.Style := [];
  end;
  inc(CurY, LineHeight);
end;

procedure TOvcCustomReportView.DoSectionFooter(Canvas: TCanvas; var CurY: Integer; LineHeight, VPage,
  PrintStartLeft: Integer);
var
  CurX,i : Integer;
begin
  if CurrentView.ShowFooter then begin
    if IsGrouped then
      Canvas.Font.Style := [fsBold];
    CurX := PrintStartLeft;
    for i := 0 to pred(CurrentView.GroupCount) do begin
      with CurrentView.ViewField[i],Field do
        if Visible then                                                {!!.03}
          if (FVPage = VPage) or (FVPage = -1) then
            CurX := PaintCell(Canvas, CurY, nil, '', CurrentView.ViewField[i], CurX,
              False, False, False, True, i = pred(CurrentView.GroupCount), -1, LineHeight);
    end;
    for i := CurrentView.GroupCount to pred(CurrentView.ViewFields.Count) do
      with CurrentView.ViewField[i],Field do
        if Visible then                                                {!!.03}
          if (FVPage = VPage) or (FVPage = -1) then
            CurX := PaintCell(Canvas, CurY, nil, FRVFooter.Section[i].Caption,
              CurrentView.ViewField[i], CurX, False,
              i >= CurrentView.GroupCount, True, True,
              i = pred(CurrentView.ViewFields.Count), -1, LineHeight);
    inc(CurY, 2*LineHeight);
    if IsGrouped then
      Canvas.Font.Style := [];
  end;
end;

function TOvcCustomReportView.CompLineWidth2(PrintStartLeft, PrintStopRight: Integer): Integer;
var
  CurX, i, VPage, Right: Integer;
begin
  VPage := 0;
  CurX := PrintStartLeft;
  for i := 0 to pred(CurrentView.ViewFields.Count) do
    with CurrentView.ViewField[i], Field do begin
      if Visible then begin                                            {!!.03}
        Right := CurX + TwipsToPixels(PrintWidth);
        if Right >= PrintStopRight then begin
          inc(VPage);
          CurX := PrintStartLeft;
        end else
          CurX := Right;
        FVPage := VPage;
      end;                                                             {!!.03}
    end;
  Result := VPage + 1;
  if PrintDetailView <> nil then
    Result := MaxI(Result, PrintDetailView.CompLineWidth2(
      PrintStartLeft + PrinterProperties.DetailIndent,
      PrintStopRight));
end;

***********************************************************************
73.     O32FlxBn      fix  OnItemChange event wasn't being fired.
***********************************************************************
Modify SetSelection as follows...

procedure TO32CustomFlexButton.SetSelection(Value: Integer);
var
  OldItem: Integer;
begin
  if Value <= ItemCollection.Count - 1 then begin
    if FActiveItem <> Value then begin
      OldItem := FActiveItem;                                         {!!.03}
      if Assigned(FOnMenuClick) then
        FOnMenuClick(Self, FActiveItem, Value);
      if (Value <> -1) then begin
        FActiveItem := Value;
        Caption := Items[Value].Caption;
        Glyph := Items[Value].Glyph;
        Layout := Items[Value].BtnLayout;
      end;
      if Assigned(FOnItemChange) then                                 {!!.03}
        FOnItemChange(self, OldItem, Value);                          {!!.03}
    end;
  end;
  PopMenuClose;
end;
{=====}

***********************************************************************
74.     O32IGrid      fix  OnCellPaint surfacing the wrong event.
***********************************************************************
Note: this modification affects designtime behaviour so a complete
rebuild of all four of the Orpheus packages is necessary!!!

!!Also!!!  This changes the event signature of the OnCellPaint event,
so after applying this fix, you will need to modify OnCellPaint events
to match.

Modify O32IGrid.pas as follows...

Modify the OnCellPaint declaration ...

  {InspectorGrid}
  TO32CustomInspectorGrid = class(TO32CustomControl)
  protected {private}
    FItemTextColor        : TColor;
  << snip >>
    FExpandGlyph          : TBitmap;

    FBeforeEdit: To32IGridItemEvent;
    FOnCellPaint: TO32IGridCellPaintEvent;                            {!!.03}
    FOnDelete: To32IGridDeleteItemEvent;
  << snip >>


Modify the event's property declaration...

  << snip >>
    property OnCollapse: To32IGridItemEvent
      read FOnCollapse write FOnCollapse;
    property OnCellPaint: TO32IGridCellPaintEvent                     {!!.03}
      read FOnCellPaint write FOnCellPaint;
    property OnGetEditMask: TO32GetEditMaskEvent
      read FOnGetEditMask write FOnGetEditMask;
    property OnGetEditText: TO32GetEditTextEvent
  << snip >>


Modify the DrawCell procedure as follows...

procedure TO32CustomInspectorGrid.DrawCell(ACol, ARow: Longint; ARect: TRect;
  AState: TGridDrawState);

  << snip >>

var
  Str: string;
  GlyphRect: TRect;
  BrushColor, PenColor, FontColor: TColor;
  TransparentColor: TColor;
  SaveBrush, SavePen: TColor;
  Item: TO32InspectorItem;
  Bmp: TBitmap;
  r, c: Integer;
  Default: boolean;                                                   {!!.03}
begin
  if FItems.VisibleItems.Count < 1 then exit;

  { save colors }
  PenColor := Canvas.Pen.Color;
  BrushColor := Canvas.Brush.Color;
  FontColor := Canvas.Font.Color;

  Item := TO32InspectorItem(FItems.VisibleItems[ARow]);

  Default := true;                                                    {!!.03}
  if Assigned(FOnCellPaint) then                                      {!!.03}
    FOnCellPaint(Self, ARect, Canvas, Item.Index, icRight,            {!!.03}
      Default);                                                       {!!.03}

  if Default then begin                                               {!!.03}
    if ACol = 0 then begin
    { Paint the caption cell (left) }
      Str := Str + Item.Caption;

  << snip >>

    else begin
      Canvas.Font.Color := FItemTextColor;
      Canvas.TextRect(ARect, ARect.Left+2, ARect.Top+2,
        TO32InspectorItem(FItems.VisibleItems[ARow]).AsString);
    end;
  end;                                                                {!!.03}
  {else if Assigned(FOnCellPaint) then}                               {!!.03}
    {FOnCellPaint(Self, ARect, Canvas, Item, Cell, Default);}         {!!.03}

  { restore colors }
  Canvas.Pen.Color := PenColor;
  Canvas.Brush.Color := BrushColor;
  Canvas.Font.Color := FontColor;
end;
{=====}

{...}


***********************************************************************
75.     OvcRegIS      fix  Delphi 6 requires DsgIntf be replaced by
        OvcRegAP           DesignIntf.
        OvcRegFF
        OvcRegTT
        OvcRxPe
***********************************************************************
Replaced DsgnIntf with this...

  {!!.03}
  {$IFDEF VERSION6} DesignIntf, DesignEditors, {$ELSE} DsgnIntf, {$ENDIF}


***********************************************************************
76.     O32TCFlx      fix  TO32TCValidatorOptions ValidatorClass
                           property needs to be demoted from published
                           to public. (This only affects BCB users)
***********************************************************************
Note: This is to solve a BCB problem only.  Delphi users are not
affected by this problem as Delphi is smart enough to automatically
demote incorrectly published properties. BCB users will need to rebuild
your packages and move the new header files into the proper
Orpheus\hpp? directory.

Modify the TO32TCValidatorOptions class declaration as follows...

  {Class for storing the validation properties.  These properties will be
   loaded dynamically when the editor is created.}
  TO32TCValidatorOptions = class(TPersistent)
  protected {private}
    FValidationType : TValidationType;
    FValidatorType  : String;
    FValidatorClass : TValidatorClass;
    FMask           : String;
    FLastValid      : Boolean;
    FLastErrorCode  : Word;
    FBeepOnError    : Boolean;
    FInputRequired  : Boolean;

    procedure SetValidatorType(const VType: String);
    procedure AssignValidator;
  public
    constructor Create; dynamic;
    property LastValid: Boolean
      read FLastValid write FLastValid;
    property LastErrorCode: Word
      read FLastErrorCode write FLastErrorCode;

    {!!.03 - Moved from published}
    property ValidatorClass: TValidatorClass
      read FValidatorClass write FValidatorClass stored true;
  published
    property BeepOnError: Boolean
      read FBeepOnError write FBeepOnError stored true;
    property InputRequired: Boolean
      read FInputRequired write FInputRequired stored true;
    property ValidatorType : string
      read FValidatorType write SetValidatorType stored true;
    property ValidationType: TValidationType
      read FValidationType write FValidationType stored true;
    property Mask: String
      read FMask write FMask stored true;
{    property ValidatorClass: TValidatorClass
      read FValidatorClass write FValidatorClass stored true;}
  end;


***********************************************************************
77.     O32Lkout      enh  Added a new SetActiveItem procedure along
                           with the ability to clamp the newly selected
                           item in view.
***********************************************************************
Modify the O32LkOut.pas file as follows...

Add a new procedure declaration to the O32LookoutBar class declaration...

  TO32CustomLookOutBar = class(TO32CustomControl)
  protected {private}
    {property variables}
    FActiveFolder       : Integer;

   << snip >>

    {property methods}
    function GetFolder(Index : Integer) : TO32LookOutFolder;
  << snip >>
    procedure SetItemSpacing(Value : Word);
    procedure SetOrientation(Value: TLobOrientation);
    procedure SetSelectedItem(Value: Integer);                        {!!.03}
    procedure SetSelectedItemFont(Value : TFont);
  << snip >>

Modify the SelectedItem property declaration...

  << snip >>
    property ScrollDelta : Integer
      read FScrollDelta write SetScrollDelta default 2;
    property SelectedItem : Integer
      read FSelectedItem write SetSelectedItem;                       {!!.03}
  << snip >>

Add the new procedure definition ...

<< snip >>

{!!.03 - Added}
procedure TO32CustomLookOutBar.SetSelectedItem(Value: Integer);
begin
  if (Value <> FSelectedItem) and (Value < Folders[FActiveFolder].ItemCount)
  then begin
    FSelectedItem := Value;
    lobTopItem := SelectedItem;
    Invalidate;
  end;
end;
{=====}

procedure TO32CustomLookOutBar.SetSelectedItemFont(Value : TFont);
begin
{...}


***********************************************************************
78.     OvcTimer      fix  Moved the Timer Handle removal back up above
                           the event handler calls, again.
***********************************************************************
Modify the DoTriggerNotification procedure as follows...
(Note the !!.03 change markers)

procedure TOvcTimerPool.DoTriggerNotification;
  {-conditionally sends notification for all events}
var
  ER : PEventRec;
  TC : LongInt;
  I  : Integer;
  ET : longint;
begin
  TC := GetTickCount;

  {cycle through all triggers}
  I := 0;
  while I < tpList.Count do begin
    ER := PEventRec(tpList[I]);
    if ER^.erEnabled then begin
      {is it time to fire this trigger}
      if (TC < ER^.erLastTrigger) then
        ET := (High(LongInt) - ER^.erLastTrigger) + (TC - Low(LongInt))
      else
        ET := TC - ER^.erLastTrigger;

      if (ET >= LongInt(ER^.erInterval)-tpDefHalfMinInterval) then begin
        {update event record with this trigger time}
        ER^.erLastTrigger := TC;

        {check if total elapsed time for trigger >= MaxLongInt}
        if ((MaxLongInt - ER^.erElapsed) < ET) then
          ER^.erElapsed := MaxLongInt
        else
          ER^.erElapsed := ER^.erElapsed + ET;

{!!.03 - Moved}
        if not ER^.erRecurring then begin
          Remove(ER^.erHandle);
          Dec(I); {adjust loop index for this deletion}

        {call user event handler, if assigned}
        if Assigned(ER^.erOnTrigger) then
          ER^.erOnTrigger(Self, ER^.erHandle, ER^.erInterval, ER^.erElapsed);

        {call general event handler, if assigned}
        if Assigned(FOnAllTriggers) then
          FOnAllTriggers(Self, ER^.erHandle, ER^.erInterval, ER^.erElapsed);

{!!.03 - Moved up before the event handler calls}
(*
        if not ER^.erRecurring then begin
          Remove(ER^.erHandle);
          Dec(I); {adjust loop index for this deletion}
*)
        end;
      end;
    end;
    Inc(I);
  end;
end;


***********************************************************************
79.     OvcBase       fix  Attached Label reference isn't being nil'ed
                           in the O32CustomControl's destructor.
***********************************************************************
Make it so...

destructor TO32CustomControl.Destroy;
begin
  FLabelInfo.Visible := False;
  FLabelInfo.Free;
  FLabelInfo := nil;                                                  {!!.03}
  inherited Destroy;
end;


***********************************************************************
80.     OvcSpldg      fix  OvcSplashDialog no longer supports JPG iamge
                           files.
***********************************************************************
Modify TOvcSplashDialog.Show as follows...

procedure TOvcSplashDialog.Show;
var
  DC           : hDC;
  BitsPerPixel : Word;
begin
{!!.02 - begin}
  // if there is no image assigned then fail and bail...
  {!!.03 - Modified }
  if (FPictureHiRes.Graphic = nil) and (FPictureLoRes.Graphic = nil) then
    exit;
{!!.02 - end}

  if not Assigned(Splash) then
    Splash := TOvcfrmSplashDlg.Create(Application);
{...}


***********************************************************************
81.     OvcBase       fix  Use of an attached label marks the form as
                           dirty, even when nothing has been changed.
***********************************************************************
The Application.ProcessMessages causes the IDE to mark a form with an
attached label, as dirty, triggering a "Save Form" dialog when nothing
has been changed.

procedure TOvcAttachedLabel.SetBounds(ALeft, ATop, AWidth, AHeight: Integer);
begin
  inherited SetBounds(ALeft, ATop, AWidth, AHeight);
  SavePosition;
{!!.03}
  { The following line causes the IDE to mark the form dirty, requiring it }
  { to be saved.  Not sure what this was supposed to do, but commenting it }
  { out seems to solve the problem. }
  {Application.ProcessMessages;}
end;

***********************************************************************
82.     OvcFlxEd      enh  Added SoftValidation to the FlexEdit.
        O32VLOp1
***********************************************************************
Modify O32VLOp1.pas as follows...

  TValidatorOptions = class(TPersistent)
  protected {private}
    FOwner          : TWinControl;
    FHookedControl  : TWinControl;
    FValidationType : TValidationType;
    FValidatorType  : String;
    FValidatorClass : TValidatorClass;
    FSoftValidation : Boolean;                                        {!!.03}
    FMask           : String;
  << snip >>

      write FValidatorClass;
  published
    property BeepOnError: Boolean read FBeepOnError write FBeepOnError;

    {!!.03}
    property SoftValidation: Boolean read FSoftValidation write FSoftValidation;

  << snip >>


constructor TValidatorOptions.Create(AOwner: TWinControl);
begin
  inherited Create;

  << snip >>

  ValidatorType := 'None';
  FSoftValidation := false;                                           {!!.03}
  << snip >>

procedure TValidatorOptions.voWndProc(var Msg : TMessage);
begin
  with Msg do begin
    case FEvent of
      veOnEnter        : if Msg =  CM_ENTER   then
        Validate;

      veOnExit         : if Msg = CM_EXIT    then
        if (not Validate) and (not FSoftValidation) then              {!!.03}
          FHookedControl.SetFocus;

      {TextChanged}
      veOnChange       : if Msg = 48435 then
        Validate;

  << snip >>


-----
Modify O32FlxEd.pas as follows...

  TO32CustomFlexEdit = class(TO32CustomEdit)
  protected {private}
  << snip >>
    {Internal Variables}
    FSaveEdit        : String;     {saved copy of edit string}
    FCreating        : Boolean;

    { changed FSavedColor and FSavedFontColor to FColor and FFontColor }
    FColor           : TColor;                                        {!!.03}
    FFontColor       : TColor;                                        {!!.03}

    FUpdating        : Integer;
    feValid          : Boolean;                                       {!!.03}
  << snip >>

constructor TO32CustomFlexEdit.Create(AOwner : TComponent);
begin
  << snip >>
  TControlCanvas(FCanvas).Control := Self;

  feValid := true;                                                    {!!.03}
  FShowButton := False;
  << snip >>
  Validation := TFlexEditValidatorOptions.Create(self);
  FColor := Color;                                                    {!!.03}
  FFontColor := Font.Color;                                           {!!.03}
  FCreating := False;
end;
{=====}

  << snip >>

function TO32CustomFlexEdit.ValidateSelf: Boolean;
begin
  << snip >>
      end; {if}
    end; {VtValidator}

  end; {case}

{!!.03 - begin}
  feValid := result;
  if result then
    SaveEditString
  else
    if Validation.BeepOnError then
      MessageBeep(0);

  Invalidate;
{!!.03 - end}
end;
{=====}

  << snip >>

procedure TO32CustomFlexEdit.WMPaint(var Message: TWMPaint);
begin
  { known limitation, The ancestor is overriding the font color when the }
  { control is disabled }
  if not Enabled then begin
    inherited Color := efColors.Disabled.BackColor;
    Font.Color := efColors.Disabled.TextColor;
  end else begin
    if feValid then begin
      inherited Color := FColor;
      Font.Color := FFontColor;
    end else if Validation.SoftValidation then begin
      inherited Color := EFColors.Error.BackColor;
      Font.Color := EFColors.Error.TextColor;
    end;
  end;
  inherited;
end;
{...}


***********************************************************************
83.     O32TCFlx      fix  The OnUserValidation event was not surfaced.
***********************************************************************
Modify O32TCFlx.pas as follows...

Add a new event object...

uses
  Windows, SysUtils, Messages, Graphics, Classes, Controls, Forms, StdCtrls,
  Menus, OvcTCmmn, OvcTCell,
  OvcTCStr, O32FlxEd, O32bordr, OvcEf, OvcCmd, O32VlOp1, O32Vldtr;

type

  { Event for the TCFlexEdit User Validation }                        {!!.03}
  TTCFEUserValidationEvent =                                          {!!.03}
    procedure(Sender : TObject; Value: string;                        {!!.03}
              var ValidEntry : Boolean) of object;                    {!!.03}

<< snip >>

Modify the TO32TCCustomFlexEdit class declaration as follows...

  TO32TCCustomFlexEdit = class(TOvcTCBaseString)
  protected {private}
    FBorderProps      : TO32TCBorderProperties;
  << snip >>
    FOnUserCommand    : TUserCommandEvent;
    FOnUserValidation : TTCFEUserValidationEvent;                     {!!.03}
  << snip >>

  public
  << snip >>
    property EditorOptions: TO32TCEditorProperties
      read FEditorOptions write FEditorOptions;
    property OnUserValidation: TTCFEUserValidationEvent               {!!.03}
      read FOnUserValidation write FOnUserValidation;                 {!!.03}
  end;

  << snip >>

Add the new property to the TO32TCFlexEdit class declaration...

  TO32TCFlexEdit = class(TO32TCCustomFlexEdit)
  published
    {properties inherited from custom ancestor}
  << snip >>
    property OnOwnerDraw;
    property OnUserValidation;                                        {!!.03}
  end;

Modify the ValidateEntry procedure as follows...

function TO32TCCustomFlexEdit.ValidateEntry: Boolean;
begin
  if Assigned(FOnUserValidation) then begin                           {!!.03}
    FOnUserValidation(FEdit, FEdit.Text, result);                     {!!.03}
    if Validation.BeepOnError then MessageBeep(0);                    {!!.03}
    exit;                                                             {!!.03}
  end;                                                                {!!.03}

  result := FEdit.ValidateSelf;
  Validation.LastValid     := FEdit.Validation.LastValid;
  Validation.LastErrorCode := FEdit.Validation.LastErrorCode;
end;
{...}



***********************************************************************
84.     OvcMRU        enh  The OvcMRU menu items were modified to
                           default the hint property to the MRU Item's
                           text.
***********************************************************************
Modify GenerateMRUItems as follows...
(Note changes marked with {!!.03})

{ GenerateMenuItems internal method. Does all the work }
{ of updating the menu. }
procedure TOvcMenuMRU.GenerateMenuItems;
var
  I   : Integer;
  J   : Integer;
  N   : Integer;
  MI  : TMenuItem;
begin
  { FMenuItem might not be assigned yet or the MUR list may }

  << snip >>

  N := 0;
  for J := 0 to Pred(FItems.Count) do begin
    try
      { Create a new TMenuItem. }
      MI := TMenuItem.Create(FMenuItem.Parent);
      MI.Enabled := FEnabled;
      MI.GroupIndex := FGroupIndex;
      {MI.Hint := FHint;}                                             {!!.03}
      { Generate a Name base on the property Name. This  }
      { is necessary so that multiple TOvcMenuMRUs don't }
      { conflict with one another. }
      MI.Name := 'OvcMRU' + Name + IntToStr(J + 1);
      { Assign the OnClick event to our handler. }
      MI.OnClick := MenuClick;
      { Save the item's position in the string list so that }
      { we can send it to the user in the OnClick event. }
      MI.Tag := J;
      { Don't add numeric values to separators. }
      if FItems[J] = '-' then
        MI.Caption := '-'
      else begin
        Inc(N);
        MI.Caption := FixupDisplayString(FItems[J], N);
      end;
      FMenuItem.Insert(I + J, MI);
      MI.Hint := FItems[J];                                            {!!.03}
      except
        {}
      end;
  end;
end;
{...}


***********************************************************************
85.     OvcTCHdr      fix  Bug prevented the column header caFontColor
                           from respecting the font color settings.
***********************************************************************
(Note the lines with {!!.03} change markers)

In the TOvcTCColHead.tcPaint procedure, Change this...

    { Set the cell color and font }                                   {!!.02}
    if not TableColor then                                            {!!.02}
      CA.caColor := Color;                                            {!!.02}
    if not TableFont then                                             {!!.02}
      CA.caFont.Assign(Font);                                         {!!.02}
      CA.caFontColor := Font.Color;                                   {!!.02}

to this...

    { Set the cell color and font }                                   {!!.02}
    if not TableColor then                                            {!!.02}
      CA.caColor := Color;                                            {!!.02}
    if not TableFont then begin                                       {!!.03}
      CA.caFont.Assign(Font);                                         {!!.02}
      CA.caFontColor := Font.Color;                                   {!!.02}
    end;                                                              {!!.03}



***********************************************************************
86.     OvcPf         fix  Substitution characters don't get replaced
                           in a date or time picture field.
***********************************************************************
Modify TOvcCustomPictureField.efTransfer as follows...

function TOvcCustomPictureField.efTransfer(DataPtr : Pointer; TransferFlag : Word) : Word;
  {-transfer data to/from the entry fields}
var
  P      : PChar absolute DataPtr;

  << snip >>

  procedure TransferComp;
    {-transfer data to or from Comp fields}
  var
    C : Comp;

  << snip >>

  {!!.03 - start}
  procedure ReplaceSubstChars;
  var
    J: integer;
    PicChar: AnsiChar;
  begin
    for J := 0 to StrLen( efEditSt ) - 1 do
      if pbIsLiteral( J ) then begin
        PicChar := efNthMaskChar( J );
        case PicChar of
          Subst1..Subst8: efEditSt[ J ] := UserData.SubstChars[ PicChar ];
        end;
      end;
  end;
  {!!.03 - end}

  {revised}
  procedure TransferDate;
  begin
    if TransferFlag = otf_GetData then
      TStDate(DataPtr^) := IntlSupport.DatePCharToDate(efPicture, efEditSt,
        GetEpoch)
    else begin                                                        {!!.03}
      IntlSupport.DateToDatePChar(efEditSt, efPicture, TStDate(DataPtr^), False);
      ReplaceSubstChars;                                              {!!.03}
    end;                                                              {!!.03}
  end;

  procedure TransferTime;
    {-transfer data to or from Time fields}
  begin
    if TransferFlag = otf_GetData then
      TStTime(DataPtr^) := IntlSupport.TimePCharToTime(efPicture, efEditSt)
    else begin                                                        {!!.03}
      IntlSupport.TimeToTimePChar(efEditSt, efPicture, TStTime(DataPtr^), False);
      ReplaceSubstChars;                                              {!!.03}
    end;                                                              {!!.03}
  end;

begin  {transfer}
{...}

***********************************************************************
87.     OvcCal        fix  There is no way to change the calendar's
                           background color
***********************************************************************
Surface the ancestor's Color property as follows....

  TOvcCalendar = class(TOvcCustomCalendar)
  published
    {properties}
    {$IFDEF VERSION4}
    property Anchors;
    property Constraints;
    property DragKind;
    {$ENDIF}
    property About;
    property Align;
    property BorderStyle;
    property Colors;
    property Color;                                                   {!!.04}
    property Ctl3D;
  {...}

and modify the .Paint procedure as follows...

procedure TOvcCustomCalendar.Paint;
var
  R, C     : Integer;
  I        : Integer;
  << snip >>

begin
  Canvas.Font := Font;
  Canvas.Brush.Color := Color;{clBtnFace;}                            {!!.04}
  Canvas.FillRect(ClientRect);


***********************************************************************
  88.     OvcTable      fix  OnEnteringColumn and OnEnteringRow were
                           being fired at the wrong times.
***********************************************************************
Make the following 4 modifications to OvcTable.pas (note the !!.04 change
markers)...

Add the following lines to tbSetActiveCellPrim.

{--------}
procedure TOvcCustomTable.tbSetActiveCellPrim(RowNum : TRowNum; ColNum :
TColNum);
  var
    TempInvCells : TOvcCellArray;
  begin
    {verify the row/column numbers to be visible}
    RowNum := IncRow(RowNum, 0);
  << snip >>
      tbInvCells.DeleteCell(ActiveRow, ActiveCol);
      TempInvCells.AddCell(ActiveRow, ActiveCol);
      FActiveRow := RowNum;
      FActiveCol := ColNum;
      DoEnteringRow(FActiveRow);
{!!.04}
      DoEnteringColumn(FActiveCol);
{!!.04}
      tbDrawInvalidCells(TempInvCells);
{...}

---
Comment out DoEnteringRow and DoEnteringColumn from tbDrawRow.

procedure TOvcCustomTable.tbDrawRow(RowInx : integer; ColInxStart, ColInxEnd
: integer);
  var
    RowOfs    : integer;
    RowHt     : integer;

  << snip >>

    IsActiveRow : boolean;
  begin
    {calculate data about the row, tell the user we're entering the row}

  << snip >>

    RowIsLocked := RowNum < LockedRows;
    {don't do EnteringRow when we are only painting!  Sheesh! - !!.04}
    {DoEnteringRow(RowNum);}

    {set up the cell attribute record}
    FillChar(CellAttr, sizeof(CellAttr), 0);

  << snip >>

            ColNum := Ay[ColInx].Number;
            ColOfs := Ay[ColInx].Offset;
            ColWd := Ay[succ(ColInx)].Offset - ColOfs;
          end;
        ColIsLocked := (ColNum < LockedCols);
        {Don't do EnteringColumn when we are only painting!  Sheesh - !!.04}
        {DoEnteringColumn(ColNum);}
{...}


***********************************************************************
89.     Ovcef         fix  If the value of RangeHi or RangeLo being
                           changed caused the value of the field to be
                           out of range, the error wasn't being thrown,
                           and the field's display wasn't being
                           updated.
***********************************************************************
To fix, modify the following procedures in OvcEf.pas...

procedure TOvcBaseEntryField.SetRangeHi(const Value : TRangeType);
  {-set the high range for this field}
begin
  case efDataType mod fcpDivisor of
    fsubLongInt  : efRangeHi.rtLong := Value.rtLong;
    fsubWord     : efRangeHi.rtLong := Value.rtWord;
    fsubInteger  : efRangeHi.rtLong := Value.rtInt;
    fsubByte     : efRangeHi.rtLong := Value.rtByte;
    fsubShortInt : efRangeHi.rtLong := Value.rtSht;
    fsubExtended : efRangeHi.rtExt  := Value.rtExt;
    fsubDouble   : efRangeHi.rtExt  := Value.rtDbl;
    fsubSingle   : efRangeHi.rtExt  := Value.rtSgl;
    fsubComp     : efRangeHi.rtExt  := Value.rtComp;
  else
    efRangeHi := Value;
  end;
  if ValidateContents(true) > 0 then                                  {!!.04}
    SetFocus;                                                         {!!.04}
end;

procedure TOvcBaseEntryField.SetRangeHiStr(const Value : string);
  {-set the high field range from a string value}
var
  R : TRangeType;
begin
  R := efRangeHi;
  if not (csLoading in ComponentState) then
    if not efStRangeToRange(Value, R) then
      raise EInvalidRangeValue.Create(efDataType mod fcpDivisor);
  efRangeHi := R;
  if ValidateContents(true) > 0 then                                  {!!.04}
    SetFocus;                                                         {!!.04}
end;

procedure TOvcBaseEntryField.SetRangeLo(const Value : TRangeType);
  {-set the low range for this field}
begin
  case efDataType mod fcpDivisor of
    fsubLongInt  : efRangeLo.rtLong := Value.rtLong;
    fsubWord     : efRangeLo.rtLong := Value.rtWord;
    fsubInteger  : efRangeLo.rtLong := Value.rtInt;
    fsubByte     : efRangeLo.rtLong := Value.rtByte;
    fsubShortInt : efRangeLo.rtLong := Value.rtSht;
    fsubExtended : efRangeLo.rtExt  := Value.rtExt;
    fsubDouble   : efRangeLo.rtExt  := Value.rtDbl;
    fsubSingle   : efRangeLo.rtExt  := Value.rtSgl;
    fsubComp     : efRangeLo.rtExt  := Value.rtComp;
  else
    efRangeLo := Value;
  end;
  if ValidateContents(true) > 0 then                                  {!!.04}
    SetFocus;                                                         {!!.04}
end;

procedure TOvcBaseEntryField.SetRangeLoStr(const Value : string);
  {-set the low field range from a string value}
var
  R : TRangeType;
begin
  R := efRangeLo;
  if not (csLoading in ComponentState) then
    if not efStRangeToRange(Value, R) then
      raise EInvalidRangeValue.Create(efDataType mod fcpDivisor);
  efRangeLo := R;
  if ValidateContents(true) > 0 then                                  {!!.04}
    SetFocus;                                                         {!!.04}
end;


***********************************************************************
90.     OvcTimer      fix  Timer failed to call user defined trigger
                           events for anytihng but recurring timers.
***********************************************************************
Modify DoTriggerNotification as follows...
(Note !!.04 change markers)

procedure TOvcTimerPool.DoTriggerNotification;
  {-conditionally sends notification for all events}
var
  ER : PEventRec;
  TC : LongInt;
  I  : Integer;
  ET : longint;
begin
  TC := GetTickCount;

  {cycle through all triggers}
  I := 0;
  while I < tpList.Count do begin
    ER := PEventRec(tpList[I]);
    if ER^.erEnabled then begin
      {is it time to fire this trigger}
      if (TC < ER^.erLastTrigger) then
        ET := (High(LongInt) - ER^.erLastTrigger) + (TC - Low(LongInt))
      else
        ET := TC - ER^.erLastTrigger;

      if (ET >= LongInt(ER^.erInterval)-tpDefHalfMinInterval) then begin
        {update event record with this trigger time}
        ER^.erLastTrigger := TC;

        {check if total elapsed time for trigger >= MaxLongInt}
        if ((MaxLongInt - ER^.erElapsed) < ET) then
          ER^.erElapsed := MaxLongInt
        else
          ER^.erElapsed := ER^.erElapsed + ET;

{!!.03 - Moved}
        if not ER^.erRecurring then begin
          Remove(ER^.erHandle);
          Dec(I); {adjust loop index for this deletion}
        end;                                                          {!!.04}

        {call user event handler, if assigned}
        if Assigned(ER^.erOnTrigger) then
          ER^.erOnTrigger(Self, ER^.erHandle, ER^.erInterval, ER^.erElapsed);

        {call general event handler, if assigned}
        if Assigned(FOnAllTriggers) then
          FOnAllTriggers(Self, ER^.erHandle, ER^.erInterval, ER^.erElapsed);

{!!.03 - Moved up before the event handler calls}
(*
        if not ER^.erRecurring then begin
          Remove(ER^.erHandle);
          Dec(I); {adjust loop index for this deletion}
        end;                                                          {!!.04}
*)                                                                    {!!.04}
      end;
    end;
    Inc(I);
  end;
end;


***********************************************************************
91.     OvcCmbx       fix  ComboBox Height would not change with
                           font height changes.
***********************************************************************
Modify SetItemHeight as follows...

{Changed !!.04}
procedure TOvcBaseComboBox.SetItemHeight(Value : Integer);
begin
  if Value <> FItemHeight then begin
    FItemHeight := Value;
    {$IFDEF VERSION6}
    inherited SetItemHeight(Value);
    {$ELSE}
    SetItemHeight(Value);
    {$ENDIF}
    RecreateWnd;
  end;
end;


***********************************************************************
92.     OvcDbIdx      fix  Delphi 6 throws an access violation when the
                           TOvcDbIndexSelect is destroyed.
***********************************************************************

Move the ClearObjects call from WMDestroy to the destructor.

Modify WMDestroy as follows...

procedure TOvcDbIndexSelect.WMDestroy(var Msg : TWMDestroy);
begin
{ moved to the Destructor }
//  ClearObjects;                                                     {!!.04}

  inherited;
end;


Modify the component's destructor as follows...

destructor TOvcDbIndexSelect.Destroy;
begin
  {moved from WMDestroy}
  ClearObjects;                                                       {!!.04}

  FDataLink.Free;
  FDataLink := nil;
{...}


***********************************************************************
93.     ovcbcalc      fix  memory leak.  FButtonGlyph wasn't being
                           freed.
***********************************************************************

destructor TOvcBorderEdPopup.Destroy;
begin
  if FButtonGlyph <> nil then                                         {!!.04}
    FButtonGlyph.Free;                                                {!!.04}
  inherited Destroy;
end;


***********************************************************************
94.     OvcBordr      fix  memory leak. FLabelInfo wasn't being freed.
***********************************************************************

destructor TOvcBorderParent.Destroy;
begin
  {detatch and destroy label, if any}
  FLabelInfo.Visible := False;

  {dispose the borders object}
  FBorders.Free;
  FLabelInfo.Free;                                                    {!!.04}
  FBorders := nil;
  FLabelInfo := nil;                                                  {!!.04}

  inherited Destroy;
end;


***********************************************************************
95.     O32TCFlx      fix  memory leak. FValidation wasn't being freed.
***********************************************************************

destructor TO32TCCustomFlexEdit.Destroy;
begin
  FEditorOptions.Free;
  FBorderProps.Free;
  FValidation.Free;                                                   {!!.04}
  inherited;
end;
{=====}


***********************************************************************
96.     OvcFmCbx      fix  memory leaks. The objects assigned to the
                           items list were not being freed.
***********************************************************************
Many changes to prevent memory leaks in the Association ComboBox.

Modify SaveObjects as follows...

procedure TOvcAssociationComboBox.vSaveObjects;
begin
  if (FSavedItemList <> nil) then begin                               {!!.04}
    vFreeObjects;
    FSavedItemList.Clear;
    FSavedItemList.Assign(FMRUList.Items);
  end;                                                                {!!.04}
end;

Modify DestroyWnd as follows...

procedure TOvcAssociationComboBox.DestroyWnd;
var                                                                   {!!.04}
  I: integer;                                                         {!!.04}
begin
  if not (csDesigning in ComponentState) then begin
    vSaveObjects;
    {free association objects}                                        {!!.04}
    for I := 0 to Items.Count do                                      {!!.04}
      TOvcAssociationItem(Items.Objects[I]).Free;                     {!!.04}
  end;
  inherited DestroyWnd;
end;

Modify CreateWnd as follows...

procedure TOvcAssociationComboBox.CreateWnd;
begin
  inherited CreateWnd;
  if not (csDesigning in ComponentState) then begin                   {!!.04}
    vFreeObjects;                                                     {!!.04}
    FSavedItemList.Clear;
  end;                                                                {!!.04}
end;

procedure TOvcAssociationComboBox.Populate;
var
  Reg  : TRegistry;
  SL : TStringList;
  I, P, L  : Integer;
  FileExtension : string;
  ClassID : string;
  ClassDescription : string;
  DefaultStr : string;
  Obj : TOvcAssociationItem;
begin
  SL := TStringList.Create;
  Reg := TRegistry.Create;
  try                                                                 {!!.04}
    Reg.RootKey := HKEY_CLASSES_ROOT;
  << snip >>
      end;
  finally                                                             {!!.04}
    Reg.Free;                                                         {!!.04}
    SL.Free;                                                          {!!.04}
  end;                                                                {!!.04}
end;


***********************************************************************
97.     OvcCklb       enh  Added OwnerDrawCheck event.
***********************************************************************
This change adds a new event to the object inspector. You must rebuild
your packages to get the new event to show up at designtime.

Many changes made to the unit, as follows...

Add a new event to the top of the unit.

type
  TOvcCheckStyle = (csCheck, csX);

  TOvcStateChangeEvent = procedure (Sender : TObject; Index : Integer;
    OldState, NewState : TCheckBoxState) of object;

  {!!.04 - new event}
  TOvcOwnerDrawCheckEvent = procedure(Sender: TObject; Canvas: TCanvas;
    R: TRect; AState: TOwnerDrawState; CheckStyle: TOvcCheckStyle) of object;
{...}

Add a new event variable to the CheckList class...

  TOvcCheckList = class(TOvcCustomListBox)
  protected {private}
    {property variables}
    FBoxColor       : TColor;         {box background color}
  << snip >>

    {event variables}
    FOnStateChange  : TOvcStateChangeEvent;
    FOwnerDrawCheck : TOvcOwnerDrawCheckEvent;                        {!!.04}

    {internal variables}
    clGrayBitmap    : TBitmap;        {gray brush bitmap}
    clDrawBmp       : TBitmap;

  << snip >>

  published
    property BoxClickOnly : Boolean
      read FBoxClickOnly write FBoxClickOnly;
  << snip >>

    {events}
    property OnStateChange  : TOvcStateChangeEvent
      read FOnStateChange write FOnStateChange;

    property OwnerDrawCheck: TOvcOwnerDrawCheckEvent                  {!!.04}
      read FOwnerDrawCheck write FOwnerDrawCheck;                     {!!.04}

  {...}

Modify DrawItem as follows...

procedure TOvcCheckList.DrawItem(Index : Integer; Rect : TRect; AState : TOwnerDrawState);
var
  W  : Integer;
  X  : Integer;
  Y  : Integer;
  DY : Integer;
  M  : Integer;
  R  : TRect;
  NR : TRect;
  B  : array[0..255] of Char;
begin
  NR := Classes.Rect(0, 0, Rect.Right - Rect.Left, Rect.Bottom - Rect.Top);

  << snip >>

  {determine width/height of the rectangle}
  W := NR.Bottom - NR.Top - 2*M;

  { Forcing the checkbox width to an odd value causes the interior width }
  { to be an even value, which is contrary to the point                  }
  if {not} Odd(W) then                                                {!!.04}
    Dec(W);

  {draw the box}
  if odGrayed in AState then
    clDrawBmp.Canvas.Brush.Bitmap := clGrayBitmap
  else begin
    clDrawBmp.Canvas.Brush.Bitmap := nil;
    clDrawBmp.Canvas.Brush.Color := FBoxColor;
  end;
  X := NR.Left + M;
  Y := NR.Top + M;
  clDrawBmp.Canvas.Pen.Color := RGB(192,204,216);
  clDrawBmp.Canvas.Rectangle(X, Y, X+W, Y+W);
  clDrawBmp.Canvas.Pen.Color := RGB(80,100,128);
  clDrawBmp.Canvas.PolyLine([Point(X,     Y+W-2),
                             Point(X,     Y),
                             Point(X+W-1, Y)]);
  clDrawBmp.Canvas.Pen.Color := clBlack;
  clDrawBmp.Canvas.PolyLine([Point(X+1,   Y+W-3),
                             Point(X+1,   Y+1),
                             Point(X+W-2, Y+1)]);
  clDrawBmp.Canvas.Pen.Color := RGB(128,152,176);
  clDrawBmp.Canvas.PolyLine([Point(X+1,   Y+W-2),
                             Point(X+W-2, Y+W-2),
                             Point(X+W-2, Y)]);

  { Let the owner draw the check mark }                               {!!.04}
  if Assigned(FOwnerDrawCheck) then begin                             {!!.04}
    R := Classes.Rect(X + 3, Y + 3, X + W - 3, Y + W - 3);            {!!.04}
    FOwnerDrawCheck(self, clDrawBmp.Canvas, R, AState, CheckStyle);   {!!.04}
  end else begin                                                      {!!.04}
    { draw the check mark or the X }
    clDrawBmp.Canvas.Pen.Color := CheckColor;
    if (odChecked in AState) or (odGrayed in AState) then begin
      R := Classes.Rect(X+3, Y+3, X+W-3, Y+W-3);
      case CheckStyle of
        csX : with clDrawBmp.Canvas do begin
        {X}
          MoveTo(R.Left, R.Top);
  << snip >>
          LineTo(R.Right, R.Top);
        end;
        csCheck : with clDrawBmp.Canvas do begin
        {check}
          MoveTo(R.Left, R.Bottom-5);
  << snip >>
          LineTo(R.Right,  R.Top+1);
        end;
      end;
    end;
  end; { if OwnerDrawCheck }                                          {!!.04}

  {draw glyphs if enabled}

{...}


***********************************************************************
98.     Ovccklb       enh  Added ReadOnly property.
***********************************************************************
Modify OvcCklb.pas as follows...

Modify TOvcCheckList class as follows...

  TOvcCheckList = class(TOvcCustomListBox)
  protected {private}
    {property variables}
    FBoxColor       : TColor;         {box background color}
  << snip >>
    FStates         : TList;          {check state}
    FReadOnly       : Boolean;        {read only}                     {!!.04}
  << snip >>

  published
    property BoxClickOnly : Boolean
      read FBoxClickOnly write FBoxClickOnly;
  << snip >>
    property LabelInfo : TOvcLabelInfo
      read FLabelInfo write FLabelInfo;
    property ReadOnly: Boolean                                        {!!.04}
      read FReadOnly write FReadOnly default false;                   {!!.04}
    property ShowGlyphs : Boolean
  {...}

Modify KeyPress as follows...

procedure TOvcCheckList.KeyPress(var Key: Char);
var
  State : TCheckBoxState;
  Tmp : TNotifyEvent;
begin
  inherited KeyPress(Key);

  if (not ReadOnly)                                                   {!!.04}
  and (ItemIndex >= 0)
  and (ItemIndex < Items.Count) then
  begin
    State := Self.States[ItemIndex];
    case State of
      cbUnchecked:
        if ThreeState then
          State := cbGrayed
        else
          State := cbChecked;
      cbChecked: State := cbUnchecked;
      cbGrayed: State := cbChecked;
    end;
    Self.States[ItemIndex] := State;

    Tmp := OnClick;
    if (Assigned(Tmp)) then
      OnClick(Self);
  end;
end;


Modify WMLButtonDown as follows...

procedure TOvcCheckList.WMLButtonDown(var Msg : TWMLButtonDown);
var
  I : Integer;
  P : TPoint;
  R : TRect;
begin
  P.X := Msg.XPos;
  P.Y := Msg.YPos;
  I := ItemAtPos(P, True);
  FillChar(R, SizeOf(R), 0);
  if I > -1 then
    SendMessage(Handle, LB_GETITEMRECT, I, LongInt(@R));

  {eat click if clicking on the check box}
  if (Msg.XPos > R.Left + ItemHeight - BoxMargin div 2) then begin    {!!.04}
    if not ReadOnly then                                              {!!.04}
      inherited;                                                      {!!.04}
  end else                                                            {!!.04}
    InvalidateRect(Handle, @R, True);

  if not FReadOnly and (I > -1) then begin                            {!!.04}
    if (not FBoxclickOnly) or ((Msg.XPos >= R.Left) and
       (Msg.XPos <= R.Left + ItemHeight - BoxMargin div 2)) then begin
      case States[I] of
{...}


***********************************************************************
99.     O32IGrid      enh  Hint and Tag properties have been published.
***********************************************************************

  TO32InspectorGrid = class(TO32CustomInspectorGrid)
  published
    property Align;
  << snip >>
    property Enabled;
    property ExpandGlyph;
    property Font;
    property GridLineColor;
    property Hint;                                                    {!!.04}
    property ItemCollection;
    property ItemTextColor;
    property Images;
    property LabelInfo;
    property ParentColor;
    property ParentShowHint;                                          {!!.04}
    property ReadOnly;
    property Selected;
    property ShowHint;                                                {!!.04}
    property Sorted;
    property TabOrder;
    property TabStop;
    property Tag;                                                     {!!.04}
    property Visible;
  {...}


***********************************************************************
100.    O32FlxEd      fix  FlexEdit wouldn't adjust its height when the
                           font was changed.
***********************************************************************
Add a new CMFontChanged message handler to the TO32CustomFlexEdit
class.

    TO32CustomFlexEdit = class(TO32CustomEdit)
  protected {private}
    FAlignment        : TAlignment;
    FBorders          : TO32Borders;
  << snip >>

    {Message Handlers}
    procedure WMGetDlgCode (var Message : TWMGetDlgCode); message WM_GETDLGCODE;
    procedure CMMouseEnter (var Message : TMessage);      message CM_MOUSEENTER;
    procedure CMMouseLeave (var Message : TMessage);      message CM_MOUSELEAVE;
    procedure CMGotFocus   (var Message : TMessage);      message WM_SETFOCUS;
    procedure CMLostFocus  (var Message : TMessage);      message WM_KILLFOCUS;

    {!!.04 - added}
    procedure CMFontChanged(var Message: TMessage);       message CM_FONTCHANGED;

    procedure WMNCPaint    (var Message : TWMNCPaint);    message WM_NCPAINT;
{...}

Define the new message handler as follows...

{!!.04 - added}
procedure TO32CustomFlexEdit.CMFontChanged(var Message: TMessage);
begin
  inherited;
  AdjustHeight;
end;
{=====}

function TO32CustomFlexEdit.GetText: String;
{...}


***********************************************************************
101.    OvcDvCbx      enh  Added a FirstScannedDrive property to
                           prevent the drive combo box from polling
                           floppies when it populates itself.
***********************************************************************
Modify the class declaration as follows...

type
  TOvcDriveComboBox = class(TOvcBaseComboBox)
  protected {private}
    {property variables}
    FDrive    : Char;
    FFirstDrive : Char;                                               {!!.04}
    FDirComboBox : TOvcDirectoryComboBox;
    FVolName  : string;

    {property methods}
    procedure SetDrive(const Value : Char);

  protected
    procedure Loaded;
      override;
    procedure Notification(AComponent: TComponent; Operation: TOperation);
      override;

    {!!.04 - Added}
    procedure SetFirstDrive(Value: Char);

  << snip >>
  published
    property DirectoryComboBox : TOvcDirectoryComboBox
      read FDirComboBox
      write FDirComboBox;

  << snip >>
    property DropDownCount;
    property Enabled;
    property FirstScannedDrive: Char                                  {!!.04}
      read FFirstDrive write SetFirstDrive;                           {!!.04}
    property Font;
    property HotTrack;

{...}

Define SetFirstDrive as follows...

{!!.04 - added}
procedure TOvcDriveComboBox.SetFirstDrive(Value: Char);
begin
  if (UpCase(Value) in ['A'..'Z']) then
    FFirstDrive := UpCase(Value)
  else
    FFirstDrive := 'A';
  Populate;
end;

Modify Populate as follows...

procedure TOvcDriveComboBox.Populate;
var
  I         : Integer;
  DriveChar : Char;
  SavedErrorMode: Word;
  VolumeStr: string;                                                  {!!.04}
begin

  ClearItems;
  SavedErrorMode := SetErrorMode(SEM_FAILCRITICALERRORS);
  try
    SendMessage(Handle, CB_DIR, DDL_Drives + DDL_Exclusive, LongInt(PChar('*.*')));
    if Items.Count > 0 then
      for I := 0 to Pred(Items.Count) do begin
        DriveChar := UpCase(Items[I][3]);

{!!.04 - begin}
        { Skip any drives that are lower than FFirstDrive }
        if DriveChar < FFirstDrive then
          Items[I] := Format('%s:', [DriveChar])
        else begin
          { prevent empty volume information from being displayed as '[]' }
          VolumeStr := GetVolume(DriveChar);
          if VolumeStr <> '[]' then
            Items[I] := Format('%s: %s', [DriveChar, VolumeStr])
          else
            Items[I] := Format('%s:', [DriveChar]);
        end;
{!!.04 - end}

        if (DriveChar = FDrive) then
          ItemIndex := I;
      end;
  finally
    SetErrorMode(SavedErrorMode);
  end;
end;

procedure TOvcDriveComboBox.SelectionChanged;
begin
  FVolName := Items[ItemIndex];
{...}



***********************************************************************
102.    O32TCFlx      fix  ButtonGlyph caused access violation at
                           designtime.
***********************************************************************
Note: This fix affects designtime behaviour so your Orpheus packages
will need to be properly rebuilt before the fix will appear at
designtime.

Add a getter and setter to the TO32TCEditorProperties class for the
ButtonGlyph property.



  TO32TCEditorProperties = class(TPersistent)
  protected
    FAlignment       : TAlignment;
  << snip >>
    FReadOnly        : Boolean;
    procedure SetButtonGlyph(Value :TBitmap);                         {!!.04}
    function GetButtonGlyph :TBitmap;                                 {!!.04}
  public
  << snip >>
  published
    {$IFDEF VERSION4}
    property Alignment: TAlignment read FAlignment write FAlignment;
    {$ENDIF}
    property ButtonGlyph: TBitmap                                     {!!.04}
      read GetButtonGlyph write SetButtonGlyph;                       {!!.04}

    property Color: TColor Read FColor write FColor;
{...}

Define them as follows...

destructor TO32TCEditorProperties.Destroy;
begin
  FButtonGlyph.Free;
  inherited Destroy;
end;
{=====}

{!!.04 - begin}
procedure TO32TCEditorProperties.SetButtonGlyph(Value :TBitmap);
begin
  FButtonGlyph.Assign(Value);
end;
{=====}

function TO32TCEditorProperties.GetButtonGlyph :TBitmap;
begin
  Result := FButtonGlyph;
end;
{=====}
{!!.04 - end}

{===== TO32TCCustomFlexEdit ==========================================}
{...}



***********************************************************************
103.    OvcCaret      fix  "No Parent Window" Error thrown in the Edit 
                           field's destructors.
***********************************************************************
Add a check for HandleAllocated before attempting to use the handle.

procedure TOvcSingleCaret.SetVisible(V : boolean);
  begin
    if (V <> FVisible) then
      begin
        FVisible := V;
        if Linked then
          if Owner.HandleAllocated then                     {!!.04}
            if FVisible then
              ShowCaret(Owner.Handle)
            else
              HideCaret(Owner.Handle);
      end;
  end;


***********************************************************************
104.    Ovc.inc       fix  CBuilder isn't being properly defined in
                           C++Builder 6. As a result, some Delphi only
                           code is being compiled instead of some
                           C++Builder specific code.
***********************************************************************
This is for C++ Builder 6 users only.

Note: you will need to rebuild your packages and header files, and move
the new header files into the Orpheus\hpp6 directory after making this
change.

Modify the General Defines as follows...

{*********************************************************}
{*                     OVC.INC 4.01                      *}
{*     Copyright (c) 1995-2000 TurboPower Software Co    *}
{*                 All rights reserved.                  *}
{*********************************************************}

{Conditional defines that affect compilation}

  << snip >>

{General define indicating use under C++ Builder}
{$IFDEF VER93}
  {$DEFINE CBuilder}
{$ENDIF}
  << snip >>
{$IFDEF VER130}
  {$IFDEF BCB}
    {$DEFINE CBuilder}
    {$ObjExportAll On}
  {$ENDIF}
{$ENDIF}
{$IFDEF VER140}                                                       {!!.04}
  {$IFDEF BCB}                                                        {!!.04}
    {$DEFINE CBuilder}                                                {!!.04}
    {$ObjExportAll On}                                                {!!.04}
  {$ENDIF}                                                            {!!.04}
{$ENDIF}                                                              {!!.04}

{...}


***********************************************************************
105.    OvcEf         fix  Leading spaces get trimmed off improperly if
                           the width of the control is too narrow to
                           allow the entire string to be displayed.

***********************************************************************
Modify EfPaintPrim as follows (Note !!.04 change marker)...

{!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
procedure TOvcBaseEntryField.efPaintPrim(DC : TOvcHdc{Hdc};
  ARect : TRect; Offset : Integer);
  {-primitive routine to draw the entry field control}
var
  X, Y      : Integer;

  << major snippage of all local functions >>

begin
  {select the font into our painting DC}
  SelectObject(DC, Font.Handle);
  SetBkColor(DC, Graphics.ColorToRGB(Color));
  SetTextColor(DC, Graphics.ColorToRGB(Font.Color));

  << snip 100 lines >>

      {the display string doesn't fit in the client area, so strip any      }
      {padding away so that the important stuff can show                    }
      if efoTrimBlanks in Options then                                {!!.04}
        while SD[0] = PadChar do begin
          for I := 0 to Length(SD) - 1 do
            SD[i] := SD[i + 1];
        end;
      ChCnt := Length(SD);
      X := LMargin-1;
    end;
  end;
{...}



***********************************************************************
106.    OvcDbCal      fix  Published the Color property in the
                           OvcDbCalendar.
***********************************************************************
Add the property Color to the class declaraton...

Note: you will need to rebuild your packages to get the new property to
show up at designtime.

type
  TOvcDbCalendar = class(TOvcCustomCalendar)
  {.Z+}
  protected {private}
    {property variables}
    FAutoUpdate  : Boolean;

   << major snippage >>

  published
    property AutoUpdate : Boolean
      read FAutoUpdate
      write FAutoUpdate;

  << snip >>

    property Colors;
    property Color;                                                   {!!.04}
    property Ctl3D;
  {...}


***********************************************************************
107.    OvcEf         fix  Fix number 105 wasn't good enough.
***********************************************************************
The code which attempts to trim extra pad characters is a mistake.  It
causes more problems than it fixes.  I took it out completely.

  {!!.02 - Hdc changed to TOvcHdc for BCB Compatibility }
procedure TOvcBaseEntryField.efPaintPrim(DC : TOvcHdc{Hdc};
  ARect : TRect; Offset : Integer);
  {-primitive routine to draw the entry field control}
var
  X, Y      : Integer;

<< major snippage >>

begin
  {select the font into our painting DC}

<< major snippage >>

  end else begin
    efRightAlignActive := efoRightAlign in Options;
    if efRightAlignActive then begin
      if (Assigned(FBorders)) then begin
        if (FBorders.RightBorder.Enabled) then
          LMargin := LMargin + FBorders.RightBorder.PenWidth;
      end;
      X := efGetTextExtent(SD, StrLen(SD));
      if X >= ClientWidth-LMargin-1 then begin
(*
!!.04 - This is a classic bad idea. It royally messes stuff up.
        {the display string doesn't fit in the client area, so strip all    }
        {padding.                                                           }
        while SD[0] = PadChar do begin
          for I := 0 to Length(SD) - 1 do
            SD[i] := SD[i + 1];
        end;
        ChCnt := Length(SD);
        efRightAlignActive := False;
*)
        X := LMargin-1;
      end else
        X := ClientWidth-X-LMargin-1;
    end else begin
      if (Assigned(FBorders)) then begin
        if (FBorders.LeftBorder.Enabled) then
          LMargin := LMargin + Borders.LeftBorder.PenWidth;
      end;
(*
!!.04 - This is a classic bad idea. It royally messes stuff up.
      {the display string doesn't fit in the client area, so strip any      }
      {padding away so that the important stuff can show                    }
      X := efGetTextExtent(SD, StrLen(SD));
      if X >= ClientWidth-LMargin-1 then
      if efoTrimBlanks in Options then                                {!!.04}
        while SD[0] = PadChar do begin
          for I := 0 to Length(SD) - 1 do
            SD[i] := SD[i + 1];
        end;
      ChCnt := Length(SD);
*)
      X := LMargin-1;
    end;
  end;

  Y := efTopMargin;
{...}

***********************************************************************
108.    OvcRptVw      fix  Report view does not allow deletion of custom
                           fields.
***********************************************************************
Report view does not allow deletion of custom fields and views event
at design time. Complains that they are default and cannot be deleted.
Fixed. Changes too extensive to list here.

***********************************************************************
109.    OvcRptVw      enh  Report view now truncates group headers if
                           they would otherwise overwrite a total column.
***********************************************************************
Also, popup hints are shown when the mouse cursor hovers over a truncated
group header.
Too many changes to list here.

***********************************************************************
110.    OvcRptVw      enh  Loading logic for custom views optimized
***********************************************************************
The load time for custom view definitions has been reduced somewhat.

***********************************************************************
111.    OvcRptVw      fix  Changing visib. of view column causes recalc.
***********************************************************************
Changing the visibility of a view column (Visible := False/True) now
causes recalculation of the views width with subsequent update of the
horizontal scroll bar.

procedure TOvcRvViewField.SetVisible(const Value: Boolean);
...
begin
...
    Changed;
    OwnerReport.WidthChanged := True;                                  {!!.04}
  end;
end;

***********************************************************************
112.    OvcRptVw      enh  View no longer scrolls when columns are resized
***********************************************************************
Views no longer set their horizontal scrolling offset back to zero when
a column is resizes with the mouse.
Too many source changes to list here.

***********************************************************************
113.    OvcRptVw      fix  Key search now works for filtered views
***********************************************************************
Key search now works correctly even if a filter is applied to the
current view.
Too many source changes to list here.

***********************************************************************
114.    OvcRptVw      fix  Group sorting on calculated fields fixed
***********************************************************************
Sorting on grouped columns that were the result of aggregate expressions
wasn't functioning properly. Fixed.
Too many changes to list here.

***********************************************************************
115.    OvcRptVw      fix  Incorrect page calc. for grouping headers
***********************************************************************
During printing, grouping headers did not always line up correctly with
their columns. To fix, make the following {!!.04} marked changes:

procedure TOvcCustomReportView.DoLine(Canvas: TCanvas; var CurY: Integer; LineHeight, VPage: Integer;
  Line, PrintStartLeft : Integer);
...
begin
    if CurrentView.ShowGroupTotals then begin
      for i := CurrentView.GroupCount to pred(CurrentView.ViewFields.Count) do
        with CurrentView.ViewField[i], Field do begin
          if Visible then begin                                        {!!.03}
            if (FVPage = VPage) or (FVPage = -1) then begin            {!!.04}
              if ComputeTotals then
                S := DoGetGroupString(CurrentView.ViewField[i], GroupRef[Line])
              else
                S := '';
              CurX := PaintCell(Canvas, CurY, nil, S,CurrentView.ViewField[i], CurX,
                False, False, ComputeTotals,
                True, i = pred(CurrentView.ViewFields.Count), -1, LineHeight);
            end;                                                       {!!.04}
          end;                                                         {!!.03}
        end;
    end;
    Canvas.Font.Style := [];
  end;
  inc(CurY, LineHeight);
end;


***********************************************************************
116.    OvcRvIdx      fix  Sorting of sub-groups not always correct
***********************************************************************
For grouped views, sorting on all but the top level was sometimes wrong.
Too many changes to list here.

***********************************************************************
117.    OvcDRpVw      enh  Various performance enhancements
***********************************************************************
Too many changes to list here.


***********************************************************************
118.    O32FlxEd      fix  FlexEdit component ignores the value of the
                           PasswordChar property.
***********************************************************************
It seems that the FlexEdit inherits some undesirable behaviour from its
ancestors.  Specifically the values of ES_MultiLine and PasswordChar
are mutually exclusive.  After this fix, if the control is multi-line
enabled then the passwordChar property is ignored.

Modify O32FlxEd.pas as follows (Note !!.04 change markers)...

procedure TO32CustomFlexEdit.CreateParams(var Params: TCreateParams);
const
  Passwords: array[Boolean] of DWORD = (0, ES_PASSWORD);              {!!.04}
  Alignments: array[Boolean, TAlignment] of DWORD =
    ((ES_LEFT, ES_RIGHT, ES_CENTER),(ES_RIGHT, ES_LEFT, ES_CENTER));
  WordWraps: array[Boolean] of DWORD = (0, ES_AUTOHSCROLL);
begin
  inherited CreateParams(Params);
  with Params do
  begin
  {!!.04 - begin}
    if MultilineEnabled then
      Style := Style and not WordWraps[FWordWrap] or ES_MULTILINE
        {$IFDEF VERSION4}
        or Alignments[UseRightToLeftAlignment, FAlignment]
        {$ENDIF}
        or WS_CLIPCHILDREN
    else
      Style := Style and not WordWraps[FWordWrap]
        or Passwords[PasswordChar <> #0]
        {$IFDEF VERSION4}
        or Alignments[UseRightToLeftAlignment, FAlignment]
        {$ENDIF}
        or WS_CLIPCHILDREN
  {!!.04 - end}
  end;
end;
{=====}

Modify MultiLineEnabled as follows...

function TO32CustomFlexEdit.MultiLineEnabled: Boolean;
begin
  { The control is only multi-line able if either WordWrap or WantReturns is }
  { set and Password char is not being used }
  result := (FWantReturns or FWordWrap) and (PasswordChar = #0);      {!!.04}
end;
{=====}

***********************************************************************
119.    O32FlxBn      fix  The FlexButton's OnChange event was being
                           fired as the button was being created,
                           before the parent form's OnCreate event was
                           fired.
***********************************************************************

Modify the SetSelection procedure as follows...

procedure TO32CustomFlexButton.SetSelection(Value: Integer);
var
  OldItem: Integer;
begin
  if Value <= ItemCollection.Count - 1 then begin
    if FActiveItem <> Value then begin
      OldItem := FActiveItem;                                         {!!.03}
      if Assigned(FOnMenuClick) then
        FOnMenuClick(Self, FActiveItem, Value);
      if (Value <> -1) then begin
        FActiveItem := Value;
        Caption := Items[Value].Caption;
        Glyph := Items[Value].Glyph;
        Layout := Items[Value].BtnLayout;
      end;
      if (not (csLoading in ComponentState))                          {!!.04}
      and Assigned(FOnItemChange) then                                {!!.04}
        FOnItemChange(self, OldItem, Value);                          {!!.03}
    end;
  end;
  PopMenuClose;
end;
{=====}


***********************************************************************
120.    O32IGrid      fix  The InspectorGrid flickers madly when the
                           columns are resized.
***********************************************************************
Modify the CustomInspectorGrid's constructor as follows...

constructor TO32CustomInspectorGrid.Create(AOwner: TComponent);
const
  GridStyle = [csCaptureMouse, csOpaque, csDoubleClicks];
begin
  inherited Create(AOwner);
  if NewStyleControls then
    ControlStyle := GridStyle
  else
    ControlStyle := GridStyle + [csFramed];

  // To prevent flickering                                            {!!.04}
  {$IFDEF VERSION4}                                                   {!!.04}
  DoubleBuffered := true;                                             {!!.04}
  {$ENDIF}                                                            {!!.04}


***********************************************************************
121.    O32IGrid      fix  Cell editors don't follow the cell when the
                           control is resized.
***********************************************************************
Modify the WMSize message handler as follows...

procedure TO32CustomInspectorGrid.WMSize(var Msg: TWMSize);
var                                                                   {!!.04}
  Rect: TRect;                                                        {!!.04}
begin
  inherited;
  SetColWidths(0, (Width - 4) div 2);
  SetCOlWidths(1, (Width - 4) div 2);

  Rect := CellRect(1, ActiveRow);                                     {!!.04}
  Rect.Top := Rect.Top + 1;                                           {!!.04}
  MoveEditor(Rect);                                                   {!!.04}

  UpdateScrollRange;
end;
{=====}


***********************************************************************
122.    O32dbFe       fix  DataType was never fully implemented in the
                           FlexEdit.  It was recently removed from the
                           component and needs to be removed from the
                           data-aware version also.
***********************************************************************

DataType was never implemented.  It was recently removed from the
component but it was overlooked in the data-aware version.  Comment out
all references to DataType in the O32DbFlexEdit.fedbSetFieldProperties
method.

procedure TO32dbFlexEdit.fedbSetFieldProperties;
begin
  case FFieldType of
    ftString {$IFDEF VERSION5}, ftWideString {$ENDIF}
      : begin
//        DataType := feString;                                       {!!.04}
        if Field <> nil then
          MaxLength := Field.DisplayWidth;
      end;

//  ftSmallInt : DataType := feInteger;                               {!!.04}
//  ftInteger  : DataType := feInteger;                               {!!.04}
//  ftWord     : DataType := feInteger;                               {!!.04}
//  ftBoolean  : DataType := feLogical;                               {!!.04}
//  ftFloat    : DataType := feFloat;                                 {!!.04}
//  ftCurrency : DataType := feExtended;                              {!!.04}
//  ftBCD      : DataType := feExtended;                              {!!.04}
//else                                                                {!!.04}
    {default to string}
//  DataType := feString;                                             {!!.04}
  end;

  {save current field type}
  if Field <> nil then
    FieldType := Field.DataType;

  {clear all states}
  fedbState := [];
end;
{=====}


***********************************************************************
122.    OvcTable      fix  The OvcTable was firing the OnEnteringRow
                           and OnEnteringCol as each cell was being
                           painted.  This is incorrect as the column
                           and row are not actually being entered, just
                           painted.
***********************************************************************
This is probably going to break some code as some developers may rely
on these events being fired as each cell is painted.  If they are, then
they shouldn't.  This fix will make the table behave as it should.

Modify tbSetActiveCellPrim as follows...

procedure TOvcCustomTable.tbSetActiveCellPrim(RowNum : TRowNum; ColNum : TColNum);
  var
    TempInvCells : TOvcCellArray;
  begin
    {verify the row/column numbers to be visible}
    RowNum := IncRow(RowNum, 0);

  << snip >>

      if (ColNum <> FActiveCol) then
        begin
          tbInvalidateColHdgPrim(FActiveCol, TempInvCells);
          InvalidateColumnHeading(ColNum);
          DoLeavingColumn(FActiveCol);
        end;
      tbInvCells.DeleteCell(ActiveRow, ActiveCol);
      TempInvCells.AddCell(ActiveRow, ActiveCol);
      if FActiveRow <> RowNum then                                    {!!.04}
        DoEnteringRow(RowNum);                                        {!!.04}
      FActiveRow := RowNum;
      if FActiveCol <> ColNum then                                    {!!.04}
        DoEnteringColumn(ColNum);                                     {!!.04}
      FActiveCol := ColNum;
      tbDrawInvalidCells(TempInvCells);
      tbEnsureRowIsVisible(RowNum);
      tbEnsureColumnIsVisible(ColNum);
  {...}

Comment out the DoEnteringColumn and DoEnteringRow calls from
tbDrawRow as follows...

procedure TOvcCustomTable.tbDrawRow(RowInx : integer; ColInxStart,
  ColInxEnd : integer);
  var
    RowOfs    : integer;
  << snip >>
    IsActiveRow : boolean;
  begin
    {calculate data about the row, tell the user we're entering the row}
    with tbRowNums^ do
      begin
        RowNum := Ay[RowInx].Number;
        RowOfs := Ay[RowInx].Offset;
        RowHt := Ay[succ(RowInx)].Offset - RowOfs;
      end;
    IsActiveRow := ActiveRow = RowNum;
    RowIsLocked := RowNum < LockedRows;
      { Don't fire the OnEnteringRow when we are painting }
//    DoEnteringRow(RowNum);                                          {!!.04}

    {set up the cell attribute record}
    FillChar(CellAttr, sizeof(CellAttr), 0);
    CellAttr.caFont := tbCellAttrFont;

    {for all required cells}
    for ColInx := ColInxEnd downto ColInxStart do
      begin
        {calculate data about the column, tell the user we're entering the column}
        with tbColNums^ do
          begin
            ColNum := Ay[ColInx].Number;
            ColOfs := Ay[ColInx].Offset;
            ColWd := Ay[succ(ColInx)].Offset - ColOfs;
          end;
        ColIsLocked := (ColNum < LockedCols);
        { Don't fire the OnEnteringColumn when we are painting }
//        DoEnteringColumn(ColNum);                                   {!!.04}

        {get the gridpen for the cell}
        if (RowIsLocked or ColIsLocked) then
  {...}


***********************************************************************
123.    OvcEF         fix  Focus problems with the Ovc*Edit fields.
***********************************************************************
Move the call to inherited to the very top of the WMLButtonDown message
handler.

procedure TOvcBaseEntryField.WMLButtonDown(var Msg : TWMLButtonDown);
begin
  inherited;                                                          {!!.04}

  if not (sefHaveFocus in sefOptions) then begin
    Include(sefOptions, sefNoHighlight);
    SetSelection(0, 0);
    if not Focused then
      SetFocus;
  end;

//  inherited;                                                        {!!.04}

  if sefHaveFocus in sefOptions then
    efPerformEdit(TMessage(Msg), ccMouse);
end;


***********************************************************************
124.    OvcTable      fix  Scrollbar recursion problems in the OvcTable
***********************************************************************
Add a ProcessingVScrollMessage flag to the TOvcCustomTable class
declaration...

  TOvcCustomTable = class(TOvcTableAncestor)
    {-The custom class for tables}
    protected {private}
      {property fields - even size}
      FActiveCol      : TColNum;             {column of active cell}
      FActiveRow      : TRowNum;             {row of active cell}

  << snip >>

      {other fields - odd size}
      tbHasHSBar : boolean;             {true if horiz scroll bar present}
      tbHasVSBar : boolean;             {true if vert scroll bar present}
      tbUpdateSBs : boolean;            {true if the scroll bars must be updated}
      tbIsSelecting : boolean;          {is in mouse selection mode}
      tbIsDeselecting : boolean;        {is in mouse deselection mode}
      tbIsKeySelecting : boolean;       {is in key selection mode}
      tbMustUpdate : boolean;           {scrolling has left an invalid region}
      tbMustFinishLoading : boolean;    {finish loading data in CreateWnd}
      ProcessingVScrollMessage: Boolean;{Internal flag}               {!!.04}

    protected
  {...}


Initialize the new flag in the constructor...

constructor TOvcCustomTable.Create(AOwner : TComponent);
  begin
    inherited Create(AOwner);

    ProcessingVScrollMessage := false;                                {!!.04}

    tbState := [otsNormal];
  {...}


Modify WMVScroll to use the new flag as follows...

procedure TOvcCustomTable.WMVScroll(var Msg : TWMScroll);

  procedure ProcessThumb;
  << snip >>
  end;

begin
  if ProcessingVScrollMessage then                                    {!!.04}
    Exit;                                                             {!!.04}
  ProcessingVScrollMessage := true;                                   {!!.04}
  try                                                                 {!!.04}
    {ignore SB_ENDSCROLL and SB_THUMBTRACK messages (the latter
     if required to by the Options property): this'll possibly
     avoid multiple validations}
    if (Msg.ScrollCode = SB_ENDSCROLL) or
       ((Msg.ScrollCode = SB_THUMBTRACK) and
        (not (otoThumbTrack in Options))) then

  << snip >>

    case Msg.ScrollCode of
      SB_LINEUP        : ProcessScrollBarClick(otsbVertical, scLineUp);
  << snip >>
      SB_THUMBTRACK    : if (otoThumbTrack in Options) then ProcessThumb;
    else
      inherited;
      Exit;
    end;
    Msg.Result := 0;
  finally                                                             {!!.04}
    ProcessingVScrollMessage := false;                                {!!.04}
  end;                                                                {!!.04}
end;

{...}


***********************************************************************
125.    OvcDrCbx      fix  FullName returned invalid results in some
                           instances.
***********************************************************************
Modify FullName as follows...

function FullName(const Directory, Str : string) : string;
var
  LastChar : Char;
begin
  if Directory = '' then
    Result := GetCurrentDir + '\' + Str                               {!!.04}
  else begin
    LastChar := Directory[Length(Directory)];
    if (LastChar = ':') or (LastChar = '\') then
      Result := Directory + Str
    else
      Result := Directory + '\' + Str;
  end;
end;


***********************************************************************
126.    OvcFmCbx      fix  fix number 96 introduces an "Index Out Of
                           Range" error.
***********************************************************************
The line...
    for I := 0 to (Items.Count) do
should read...
    for I := 0 to pred(Items.Count) do
Modify DestroyWnd appropriately.

procedure TOvcAssociationComboBox.DestroyWnd;
var
  I: integer;
begin
  if not (csDesigning in ComponentState) then begin
    vSaveObjects;
    {free association objects}                                        {!!.04}
    for I := 0 to pred(Items.Count) do                                {!!.04}
      TOvcAssociationItem(Items.Objects[I]).Free;                     {!!.04}
  end;
  inherited DestroyWnd;
end;


***********************************************************************
127.    OvcDrCbx      fix  Fix Access violation which occurs when
                           path = ''.
***********************************************************************

procedure TOvcDirectoryComboBox.Populate;
var
  SR             : TSearchRec;
  StrDirectories : TStringList;
  StrTree        : TStringList;
  I              : Integer;
  FullDirectory  : string;
  Path           : string;
begin
  FullDirectory := FullName(FDirectory, FMask);
  if FindFirst(FullDirectory, faDirectory, SR) = 0 then begin
    StrDirectories := TStringList.Create;
    StrTree := TStringList.Create;
    try
      repeat
        if (SR.Attr and faDirectory) = faDirectory then
          if (SR.Name <> '.') and (SR.Name <> '..') then begin        {!!.04}
            Path := FDirectory;
            if (Path <> '') and (Path[Length(Path)] <> '\') then
              Path := Path + '\';
            Path := Path + SR.Name;
            StrDirectories.AddObject(Path, Pointer(SR.Attr));
          end;
      until FindNext(SR) <> 0;
{...}


***********************************************************************
128.    OvcEf         fix  Fix 89 needed to check of the parent was
                           visible and enabled before attempting to
                           call SetFocus.
***********************************************************************
Modify the following four methods as shown...

procedure TOvcBaseEntryField.SetRangeHi(const Value : TRangeType);
  {-set the high range for this field}
begin
  case efDataType mod fcpDivisor of
    fsubLongInt  : efRangeHi.rtLong := Value.rtLong;
    fsubWord     : efRangeHi.rtLong := Value.rtWord;
    fsubInteger  : efRangeHi.rtLong := Value.rtInt;
    fsubByte     : efRangeHi.rtLong := Value.rtByte;
    fsubShortInt : efRangeHi.rtLong := Value.rtSht;
    fsubExtended : efRangeHi.rtExt  := Value.rtExt;
    fsubDouble   : efRangeHi.rtExt  := Value.rtDbl;
    fsubSingle   : efRangeHi.rtExt  := Value.rtSgl;
    fsubComp     : efRangeHi.rtExt  := Value.rtComp;
  else
    efRangeHi := Value;
  end;
  if (ValidateContents(true) > 0)                                     {!!.04}
  and (Parent <> nil)                                                 {!!.04}
  and (Parent.Visible)                                                {!!.04}
  and (Parent.Enabled) then                                           {!!.04}
    SetFocus;                                                         {!!.04}
end;

procedure TOvcBaseEntryField.SetRangeHiStr(const Value : string);
  {-set the high field range from a string value}
var
  R : TRangeType;
begin
  R := efRangeHi;
  if not (csLoading in ComponentState) then
    if not efStRangeToRange(Value, R) then
      raise EInvalidRangeValue.Create(efDataType mod fcpDivisor);
  efRangeHi := R;
  if (ValidateContents(true) > 0)                                     {!!.04}
  and (Parent <> nil)                                                 {!!.04}
  and (Parent.Visible)                                                {!!.04}
  and (Parent.Enabled) then                                           {!!.04}
    SetFocus;                                                         {!!.04}
end;

procedure TOvcBaseEntryField.SetRangeLo(const Value : TRangeType);
  {-set the low range for this field}
begin
  case efDataType mod fcpDivisor of
    fsubLongInt  : efRangeLo.rtLong := Value.rtLong;
    fsubWord     : efRangeLo.rtLong := Value.rtWord;
    fsubInteger  : efRangeLo.rtLong := Value.rtInt;
    fsubByte     : efRangeLo.rtLong := Value.rtByte;
    fsubShortInt : efRangeLo.rtLong := Value.rtSht;
    fsubExtended : efRangeLo.rtExt  := Value.rtExt;
    fsubDouble   : efRangeLo.rtExt  := Value.rtDbl;
    fsubSingle   : efRangeLo.rtExt  := Value.rtSgl;
    fsubComp     : efRangeLo.rtExt  := Value.rtComp;
  else
    efRangeLo := Value;
  end;
  if (ValidateContents(true) > 0)                                     {!!.04}
  and (Parent <> nil)                                                 {!!.04}
  and (Parent.Visible)                                                {!!.04}
  and (Parent.Enabled) then                                           {!!.04}
    SetFocus;                                                         {!!.04}
end;

procedure TOvcBaseEntryField.SetRangeLoStr(const Value : string);
  {-set the low field range from a string value}
var
  R : TRangeType;
begin
  R := efRangeLo;
  if not (csLoading in ComponentState) then
    if not efStRangeToRange(Value, R) then
      raise EInvalidRangeValue.Create(efDataType mod fcpDivisor);
  efRangeLo := R;
  if (ValidateContents(true) > 0)                                     {!!.04}
  and (Parent <> nil)                                                 {!!.04}
  and (Parent.Visible)                                                {!!.04}
  and (Parent.Enabled) then                                           {!!.04}
    SetFocus;                                                         {!!.04}
end;


***********************************************************************
129.    O32ImgFm      fix  The ImageForm's DragControl property should
                           not be allowed to be set to Self.  This
                           causes the ImageForm component to intercept
                           all click events as if it were the header
                           bar in a normal window.
***********************************************************************
Modify the SetDragControl method as follows...

procedure TO32CustomImageForm.SetDragControl(Control: TComponent);
begin
  { prevent the drag control property from being set to self.  }      {!!.05}
  { this causes the control to handle certain evnts improperly }      {!!.05}
  if Control = self then                                              {!!.05}
    Exit;                                                             {!!.05}

  FDragControl := Control;
end;
{=====}

